---
phase: 02.2-campaign-execution-model
plan: 03
type: execute
wave: 2
depends_on: ["02.2-02"]
files_modified:
  - src/llenergymeasure/orchestration/container.py
  - src/llenergymeasure/cli/campaign.py
autonomous: true

must_haves:
  truths:
    - "User can configure docker.strategy: persistent in .lem-config.yaml to use up + exec pattern"
    - "Ephemeral mode (run --rm) is the default and works as before"
    - "Persistent mode starts containers with docker compose up, dispatches with exec, tears down at end"
    - "CLI flag --container-strategy [ephemeral|persistent] overrides config"
  artifacts:
    - path: "src/llenergymeasure/orchestration/container.py"
      provides: "ContainerManager for persistent container lifecycle"
      contains: "class ContainerManager"
    - path: "src/llenergymeasure/cli/campaign.py"
      provides: "Dual container strategy implementation"
      contains: "--container-strategy"
  key_links:
    - from: "src/llenergymeasure/cli/campaign.py"
      to: "src/llenergymeasure/orchestration/container.py"
      via: "ContainerManager import and usage"
      pattern: "ContainerManager.*start.*exec.*stop"
    - from: "src/llenergymeasure/cli/campaign.py"
      to: "user_config.docker.strategy"
      via: "strategy selection"
      pattern: "docker.strategy.*persistent"
---

<objective>
Implement dual container strategy: ephemeral (default) and persistent (opt-in).

Purpose: Some users prefer persistent containers for faster execution during rapid iteration, even though ephemeral containers provide better isolation. This plan implements both strategies: ephemeral (docker compose run --rm) as default, and persistent (docker compose up + exec) as an opt-in.

Output: ContainerManager class for persistent container lifecycle; campaign CLI supports both strategies via config and CLI flag.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02.2-CONTEXT.md
@.planning/debug/container-strategy-research.md

@src/llenergymeasure/cli/campaign.py
@src/llenergymeasure/config/user_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContainerManager for persistent container lifecycle</name>
  <files>src/llenergymeasure/orchestration/container.py</files>
  <action>
Create a new module `container.py` implementing ContainerManager for persistent container lifecycle:

```python
"""Container lifecycle management for persistent container strategy.

Manages the lifecycle of long-running Docker containers using docker compose up/exec/down.
This is an alternative to the default ephemeral strategy (docker compose run --rm).

Persistent mode trades isolation for speed:
- Containers stay warm between experiments
- No container startup overhead per experiment
- Requires explicit teardown
- GPU memory may need manual clearing between experiments
"""

from __future__ import annotations

import subprocess
from dataclasses import dataclass, field
from typing import Literal

from loguru import logger


@dataclass
class ContainerState:
    """State of a managed container."""

    service: str
    status: Literal["stopped", "starting", "running", "error"]
    restart_count: int = 0


@dataclass
class ContainerManager:
    """Manages persistent Docker container lifecycle.

    Usage:
        manager = ContainerManager(services=["pytorch", "vllm"])
        manager.start_all()  # docker compose up -d pytorch vllm

        # For each experiment:
        result = manager.exec("vllm", ["lem", "experiment", "config.yaml"])

        manager.stop_all()  # docker compose down
    """

    services: list[str]
    warmup_delay: float = 0.0
    auto_teardown: bool = True
    _states: dict[str, ContainerState] = field(default_factory=dict, init=False)
    _started: bool = field(default=False, init=False)

    def __post_init__(self) -> None:
        """Initialize container states."""
        for service in self.services:
            self._states[service] = ContainerState(service=service, status="stopped")

    def start_all(self) -> bool:
        """Start all managed containers.

        Returns:
            True if all containers started successfully.
        """
        if self._started:
            logger.debug("Containers already started")
            return True

        logger.info("Starting containers: {}", ", ".join(self.services))

        cmd = ["docker", "compose", "up", "-d", *self.services]
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)

        if result.returncode != 0:
            logger.error("Failed to start containers: {}", result.stderr)
            for service in self.services:
                self._states[service].status = "error"
            return False

        for service in self.services:
            self._states[service].status = "running"

        self._started = True

        # Optional warmup delay after container start
        if self.warmup_delay > 0:
            import time

            logger.debug("Waiting {}s for container warmup", self.warmup_delay)
            time.sleep(self.warmup_delay)

        return True

    def exec(
        self,
        service: str,
        command: list[str],
        env: dict[str, str] | None = None,
    ) -> subprocess.CompletedProcess[str]:
        """Execute command in a running container.

        Args:
            service: Service name to exec into.
            command: Command and arguments to execute.
            env: Environment variables to pass (-e flags).

        Returns:
            CompletedProcess with return code and output.
        """
        if service not in self._states:
            msg = f"Unknown service: {service}"
            raise ValueError(msg)

        if self._states[service].status != "running":
            logger.warning(
                "Container {} not running (status: {}), attempting to start",
                service,
                self._states[service].status,
            )
            if not self.start_all():
                return subprocess.CompletedProcess(
                    args=command,
                    returncode=1,
                    stdout="",
                    stderr="Container start failed",
                )

        # Build exec command with optional env vars
        cmd = ["docker", "compose", "exec"]

        if env:
            for key, value in env.items():
                cmd.extend(["-e", f"{key}={value}"])

        cmd.extend([service, *command])

        logger.debug("Executing in {}: {}", service, " ".join(command[:3]))
        return subprocess.run(cmd, capture_output=False, text=True, check=False)

    def stop_all(self) -> bool:
        """Stop all managed containers.

        Returns:
            True if all containers stopped successfully.
        """
        if not self._started:
            logger.debug("Containers not started, nothing to stop")
            return True

        logger.info("Stopping containers: {}", ", ".join(self.services))

        cmd = ["docker", "compose", "down"]
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)

        if result.returncode != 0:
            logger.error("Failed to stop containers: {}", result.stderr)
            return False

        for service in self.services:
            self._states[service].status = "stopped"

        self._started = False
        return True

    def restart_service(self, service: str) -> bool:
        """Restart a single service.

        Args:
            service: Service name to restart.

        Returns:
            True if restart successful.
        """
        if service not in self._states:
            msg = f"Unknown service: {service}"
            raise ValueError(msg)

        state = self._states[service]
        state.restart_count += 1

        logger.info("Restarting container {} (restart #{})", service, state.restart_count)

        cmd = ["docker", "compose", "restart", service]
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)

        if result.returncode != 0:
            logger.error("Failed to restart {}: {}", service, result.stderr)
            state.status = "error"
            return False

        state.status = "running"
        return True

    def __enter__(self) -> ContainerManager:
        """Context manager entry."""
        self.start_all()
        return self

    def __exit__(self, exc_type: type | None, exc_val: BaseException | None, exc_tb: object) -> None:
        """Context manager exit - auto teardown if enabled."""
        if self.auto_teardown:
            self.stop_all()


__all__ = ["ContainerManager", "ContainerState"]
```
  </action>
  <verify>
```bash
# Verify module can be imported
python -c "from llenergymeasure.orchestration.container import ContainerManager; print('OK')"

# Verify class has required methods
python -c "from llenergymeasure.orchestration.container import ContainerManager; cm = ContainerManager(services=['pytorch']); print(hasattr(cm, 'start_all'), hasattr(cm, 'exec'), hasattr(cm, 'stop_all'))"
# Should print: True True True
```
  </verify>
  <done>ContainerManager class created with start_all(), exec(), stop_all(), restart_service() methods and context manager support.</done>
</task>

<task type="auto">
  <name>Task 2: Implement dual container strategy in campaign.py</name>
  <files>src/llenergymeasure/cli/campaign.py</files>
  <action>
Update campaign.py to support both ephemeral and persistent container strategies:

1. **Add CLI flag** for container strategy:
   ```python
   container_strategy: Annotated[
       str | None,
       typer.Option(
           "--container-strategy",
           help="Container strategy: ephemeral (run --rm, default) or persistent (up + exec)",
       ),
   ] = None,
   ```

2. **Determine effective strategy** (CLI > config > default):
   ```python
   # After loading user_config:
   effective_strategy: Literal["ephemeral", "persistent"]
   if container_strategy is not None:
       if container_strategy not in ("ephemeral", "persistent"):
           console.print(f"[red]Error:[/red] Invalid container strategy: {container_strategy}")
           console.print("Valid options: ephemeral, persistent")
           raise typer.Exit(1)
       effective_strategy = container_strategy  # type: ignore
   else:
       effective_strategy = user_config.docker.strategy
   ```

3. **Persistent mode warning** (as per CONTEXT.md decision):
   ```python
   if effective_strategy == "persistent":
       console.print(
           "\n[yellow]Persistent container mode:[/yellow] Containers will remain running "
           "between experiments.\n"
           "  - Faster execution (no container startup overhead)\n"
           "  - Less isolation (GPU memory may accumulate)\n"
           "  - Use --container-strategy ephemeral for better isolation\n"
       )
       if not yes:
           from rich.prompt import Confirm
           if not Confirm.ask("Continue with persistent mode?", default=True):
               console.print("[dim]Aborted. Use --container-strategy ephemeral[/dim]")
               raise typer.Exit(0)
   ```

4. **Refactor Docker execution** to use strategy:
   ```python
   # Before execution loop (after Docker dispatch setup):
   if use_docker_dispatch:
       if effective_strategy == "persistent":
           from llenergymeasure.orchestration.container import ContainerManager

           container_manager = ContainerManager(
               services=backends_needed,
               warmup_delay=user_config.docker.warmup_delay,
               auto_teardown=user_config.docker.auto_teardown,
           )
           container_manager.start_all()
           console.print(
               f"[dim]Persistent containers: {', '.join(backends_needed)} "
               f"(docker compose up + exec)[/dim]"
           )
       else:
           container_manager = None
           console.print(
               f"[dim]Ephemeral containers: {', '.join(backends_needed)} "
               f"(docker compose run --rm)[/dim]"
           )
   ```

5. **Update experiment execution** based on strategy:
   ```python
   # In the execution loop, modify _run_single_experiment call:
   experiment_id, exit_code = _run_single_experiment(
       experiment=experiment,
       campaign=campaign,
       dataset=dataset,
       sample_size=sample_size,
       results_dir=results_dir,
       use_docker=use_docker_dispatch,
       container_manager=container_manager if effective_strategy == "persistent" else None,
   )
   ```

6. **Update _run_single_experiment** to support ContainerManager:
   ```python
   def _run_single_experiment(
       ...,
       container_manager: ContainerManager | None = None,
   ) -> tuple[str, int]:
       ...
       if use_docker:
           if container_manager is not None:
               # Persistent mode: use exec
               cmd = [
                   "lem", "experiment", container_config_path,
                   "--yes", "--fresh",
               ]
               if dataset or campaign.dataset:
                   cmd.extend(["--dataset", str(dataset or campaign.dataset)])
               if sample_size or campaign.num_samples:
                   cmd.extend(["--sample-size", str(sample_size or campaign.num_samples)])

               # Build env vars for campaign context
               env_vars = {
                   "LEM_CAMPAIGN_ID": campaign.campaign_id,
                   "LEM_CAMPAIGN_NAME": campaign.campaign_name,
                   "LEM_CYCLE": str(experiment.cycle_index + 1),
                   "LEM_TOTAL_CYCLES": str(campaign.execution.cycles),
                   "LLM_ENERGY_VERBOSITY": os.environ.get("LLM_ENERGY_VERBOSITY", "normal"),
               }

               result = container_manager.exec(backend, cmd, env=env_vars)
               return experiment_id, result.returncode
           else:
               # Ephemeral mode: use run --rm (existing code)
               cmd = _build_docker_command(...)
               ...
   ```

7. **Teardown at end** (outside try/finally for safety):
   ```python
   # After execution loop, before campaign summary:
   if use_docker_dispatch and container_manager is not None:
       if user_config.docker.auto_teardown:
           console.print("\n[dim]Stopping persistent containers...[/dim]")
           container_manager.stop_all()
       else:
           console.print(
               "\n[yellow]Note:[/yellow] Persistent containers still running. "
               "Run 'docker compose down' to stop them."
           )
   ```
  </action>
  <verify>
```bash
# Verify CLI flag added
lem campaign --help | grep -i container-strategy

# Verify ContainerManager import
grep -n "from llenergymeasure.orchestration.container import" src/llenergymeasure/cli/campaign.py

# Verify strategy selection logic
grep -n "effective_strategy" src/llenergymeasure/cli/campaign.py
```
  </verify>
  <done>Campaign CLI supports dual container strategy: ephemeral (default) and persistent (opt-in via config or CLI flag). ContainerManager used for persistent mode lifecycle.</done>
</task>

</tasks>

<verification>
1. Run linting: `ruff check src/llenergymeasure/orchestration/container.py src/llenergymeasure/cli/campaign.py`
2. Run formatting: `ruff format src/llenergymeasure/orchestration/container.py src/llenergymeasure/cli/campaign.py`
3. Verify CLI help: `lem campaign --help | grep -A1 container-strategy`
4. Verify imports work: `python -c "from llenergymeasure.orchestration.container import ContainerManager; from llenergymeasure.cli.campaign import campaign_cmd; print('OK')"`
</verification>

<success_criteria>
- ContainerManager class in orchestration/container.py with start_all(), exec(), stop_all() methods
- Campaign CLI has --container-strategy [ephemeral|persistent] flag
- Ephemeral mode (run --rm) is default and unchanged
- Persistent mode (up + exec) works via config or CLI override
- Persistent mode shows warning and confirms with user (unless --yes)
- Auto-teardown configurable via user config
- All code passes ruff check and format
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-campaign-execution-model/02.2-03-SUMMARY.md`
</output>
