---
phase: 02-campaign-orchestrator
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/llenergymeasure/orchestration/manifest.py
autonomous: true

must_haves:
  truths:
    - "CampaignManifest tracks exp_id -> config -> backend -> container -> status -> result_path for all experiments"
    - "ManifestManager persists manifest atomically (temp-file-then-rename pattern)"
    - "ManifestManager supports resume: load existing manifest, skip completed, identify failed"
    - "ManifestManager updates manifest after each experiment completion"
    - "Manifest stores config hash for change detection on resume"
    - "Manifest entries track timestamps (started_at, completed_at) and error messages"
  artifacts:
    - path: "src/llenergymeasure/orchestration/manifest.py"
      provides: "CampaignManifestEntry, CampaignManifest models + ManifestManager class"
      exports: ["CampaignManifestEntry", "CampaignManifest", "ManifestManager"]
      min_lines: 150
  key_links:
    - from: "src/llenergymeasure/orchestration/manifest.py"
      to: "src/llenergymeasure/state/experiment_state.py"
      via: "follows StateManager atomic write pattern"
      pattern: "tmp.*rename|with_suffix.*tmp"
    - from: "src/llenergymeasure/orchestration/manifest.py"
      to: "src/llenergymeasure/config/campaign_config.py"
      via: "uses CampaignIOConfig for manifest path"
      pattern: "CampaignIOConfig|manifest_path"
---

<objective>
Create the campaign manifest persistence module with Pydantic models and atomic state management.

Purpose: CAMP-03 requirement — persistent manifest enables campaign resumption, status tracking, and result path mapping. Follows the atomic write pattern from StateManager. This is the state backbone that the orchestrator integration (Plan 06) depends on.
Output: New orchestration/manifest.py with CampaignManifest models and ManifestManager.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-CONTEXT.md
@.planning/phases/02-campaign-orchestrator/02-RESEARCH.md
@.planning/phases/02-campaign-orchestrator/02-01-SUMMARY.md
@src/llenergymeasure/state/experiment_state.py
@src/llenergymeasure/config/campaign_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create manifest Pydantic models</name>
  <files>src/llenergymeasure/orchestration/manifest.py</files>
  <action>
Create `src/llenergymeasure/orchestration/manifest.py` with manifest domain models and persistence manager.

**CampaignManifestEntry(BaseModel):**
- `exp_id: str` — Unique experiment identifier
- `config_name: str` — Stem name of the config file
- `config_path: str` — Path to experiment config (relative or absolute)
- `config_hash: str` — MD5 hash of config content for change detection
- `backend: str` — Backend name (pytorch, vllm, tensorrt)
- `container: str` — Docker service name
- `cycle_index: int` — Which cycle this experiment belongs to
- `status: Literal["pending", "running", "completed", "failed", "skipped"]`
- `result_path: str | None = None` — Path to results directory
- `started_at: datetime | None = None`
- `completed_at: datetime | None = None`
- `error: str | None = None` — Error message if failed
- `retry_count: int = 0` — Number of times this experiment has been retried

**CampaignManifest(BaseModel):**
- `campaign_id: str`
- `campaign_name: str`
- `created_at: datetime`
- `updated_at: datetime`
- `config_hash: str` — Hash of the campaign config file for change detection on resume
- `total_experiments: int`
- `experiments: list[CampaignManifestEntry]`

Properties:
- `completed_count` — Count of experiments with status "completed"
- `failed_count` — Count with status "failed"
- `pending_count` — Count with status "pending"
- `is_complete` — All experiments completed or skipped
- `progress_fraction` — completed / total

Methods:
- `get_remaining() -> list[CampaignManifestEntry]` — Returns pending + failed entries
- `get_by_status(status: str) -> list[CampaignManifestEntry]` — Filter by status
- `update_entry(exp_id: str, **kwargs)` — Update a specific entry's fields

**ManifestManager class:**
```python
class ManifestManager:
    """Persists and loads campaign manifests with atomic writes.

    Follows StateManager pattern: write to temp file, then atomic rename.
    """
```

Constructor:
- `manifest_path: Path` — Where to save the manifest JSON

Methods:

1. `save(manifest: CampaignManifest) -> None`
   - Updates `manifest.updated_at = datetime.now()`
   - Writes to `manifest_path.with_suffix('.tmp')`
   - Atomic rename to `manifest_path`
   - Creates parent directories if needed (`manifest_path.parent.mkdir(parents=True, exist_ok=True)`)

2. `load() -> CampaignManifest | None`
   - Returns None if file doesn't exist
   - Reads JSON, parses into CampaignManifest
   - Handles JSONDecodeError gracefully (log warning, return None)

3. `exists() -> bool`
   - Returns `manifest_path.exists()`

4. `create_manifest(campaign_id: str, campaign_name: str, config_hash: str, experiments: list[CampaignManifestEntry]) -> CampaignManifest`
   - Factory method creating a new manifest with timestamps

5. `check_config_changed(manifest: CampaignManifest, current_config_hash: str) -> bool`
   - Returns True if campaign config has changed since manifest was created

Use `from __future__ import annotations`, json, Path, datetime, Literal from typing.
Use loguru logger for warnings.
Add all public classes to `__all__`.
  </action>
  <verify>
    python -c "
from llenergymeasure.orchestration.manifest import (
    CampaignManifestEntry, CampaignManifest, ManifestManager
)
from datetime import datetime
from pathlib import Path
import tempfile, json

# Create manifest entries
entry1 = CampaignManifestEntry(
    exp_id='exp_001', config_name='pytorch_base', config_path='configs/pytorch_base.yaml',
    config_hash='abc123', backend='pytorch', container='pytorch',
    cycle_index=0, status='pending'
)
entry2 = CampaignManifestEntry(
    exp_id='exp_002', config_name='vllm_base', config_path='configs/vllm_base.yaml',
    config_hash='def456', backend='vllm', container='vllm',
    cycle_index=0, status='completed', result_path='results/raw/exp_002/'
)

# Create manifest
manifest = CampaignManifest(
    campaign_id='test123', campaign_name='test-campaign',
    created_at=datetime.now(), updated_at=datetime.now(),
    config_hash='campaign_hash', total_experiments=2,
    experiments=[entry1, entry2]
)
assert manifest.completed_count == 1
assert manifest.pending_count == 1
assert not manifest.is_complete
assert len(manifest.get_remaining()) == 1

# Test persistence
with tempfile.TemporaryDirectory() as td:
    mp = Path(td) / 'manifest.json'
    mgr = ManifestManager(manifest_path=mp)
    mgr.save(manifest)
    assert mp.exists()

    loaded = mgr.load()
    assert loaded is not None
    assert loaded.campaign_id == 'test123'
    assert loaded.completed_count == 1
    assert len(loaded.experiments) == 2

print('All manifest tests passed')
"
  </verify>
  <done>CampaignManifest with entry tracking, ManifestManager with atomic persistence and resume support. Config hash change detection for safe resume.</done>
</task>

</tasks>

<verification>
- `python -c "from llenergymeasure.orchestration.manifest import ManifestManager"` succeeds
- Manifest round-trips through JSON (save then load preserves all fields)
- Atomic write: temp file renamed (no partial writes on crash)
- `ruff check src/llenergymeasure/orchestration/manifest.py` passes
</verification>

<success_criteria>
- CampaignManifest tracks exp_id -> config -> backend -> status -> result_path
- ManifestManager uses atomic temp-file-then-rename pattern
- Resume support: get_remaining() returns pending + failed experiments
- Config hash enables change detection between campaign runs
</success_criteria>

<output>
After completion, create `.planning/phases/02-campaign-orchestrator/02-04-SUMMARY.md`
</output>
