---
phase: 01-measurement-foundations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/llenergymeasure/protocols.py
  - src/llenergymeasure/exceptions.py
  - src/llenergymeasure/resilience.py
  - src/llenergymeasure/security.py
autonomous: true
requirements:
  - INF-06
  - INF-18
  - INF-20

must_haves:
  truths:
    - "protocols.py defines 5 runtime-checkable Protocol classes: ModelLoader, InferenceEngine, MetricsCollector, EnergyBackend, ResultsRepository"
    - "exceptions.py defines LLEMError base and 5 subclasses: ConfigError, BackendError, PreFlightError, ExperimentError, StudyError"
    - "resilience.py provides a working retry_on_error decorator with exponential backoff"
    - "security.py provides path validation and sanitisation functions"
  artifacts:
    - path: "src/llenergymeasure/protocols.py"
      provides: "5 DI protocol interfaces for v2.0"
      exports: ["ModelLoader", "InferenceEngine", "MetricsCollector", "EnergyBackend", "ResultsRepository"]
    - path: "src/llenergymeasure/exceptions.py"
      provides: "v2.0 error hierarchy"
      exports: ["LLEMError", "ConfigError", "BackendError", "PreFlightError", "ExperimentError", "StudyError"]
    - path: "src/llenergymeasure/resilience.py"
      provides: "Retry decorator for transient errors"
      exports: ["retry_on_error"]
    - path: "src/llenergymeasure/security.py"
      provides: "Path sanitisation utilities"
      exports: ["validate_path", "is_safe_path", "sanitize_experiment_id"]
  key_links:
    - from: "src/llenergymeasure/resilience.py"
      to: "src/llenergymeasure/exceptions.py"
      via: "imports LLEMError for default retry exceptions"
      pattern: "from llenergymeasure\\.exceptions import"
    - from: "src/llenergymeasure/protocols.py"
      to: "typing.Protocol"
      via: "runtime_checkable Protocol base class"
      pattern: "@runtime_checkable"
---

<objective>
Rewrite the protocol interfaces, error hierarchy, resilience utilities, and security
module for v2.0 — establishing the type contracts and shared infrastructure that every
subsequent phase depends on.

Purpose: All later phases import from these modules. Getting the contracts right here
means Phase 2+ code is correctly typed from the start.
Output: Clean protocols.py, exceptions.py, resilience.py, security.py.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/llenergymeasure/protocols.py
@src/llenergymeasure/exceptions.py
@src/llenergymeasure/resilience.py
@src/llenergymeasure/security.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite protocols.py and exceptions.py for v2.0</name>
  <files>
    src/llenergymeasure/protocols.py
    src/llenergymeasure/exceptions.py
  </files>
  <action>
**Rewrite exceptions.py** with the v2.0 error hierarchy (per product decisions):

```python
class LLEMError(Exception):
    """Base exception for llenergymeasure."""

class ConfigError(LLEMError):
    """Invalid or missing configuration."""

class BackendError(LLEMError):
    """Error from an inference backend (load, run, timeout)."""

class PreFlightError(LLEMError):
    """Pre-flight check failed before GPU allocation."""

class ExperimentError(LLEMError):
    """Error during experiment execution."""

class StudyError(LLEMError):
    """Error during study orchestration."""
```

Remove the old v1.x exceptions: `LLMBenchError`, `ConfigurationError`, `ModelLoadError`,
`InferenceError`, `EnergyTrackingError`, `AggregationError`, `DistributedError`, `RetryableError`,
`BackendNotAvailableError`, `BackendInitializationError`, `BackendInferenceError`,
`BackendTimeoutError`, `BackendConfigError`, `InvalidStateTransitionError`.

Keep the new hierarchy flat (5 subclasses of LLEMError). No sub-sub-classes for now.
The `InvalidStateTransitionError` can be a subclass of `ExperimentError` since it relates
to experiment lifecycle. Add it as:
```python
class InvalidStateTransitionError(ExperimentError):
    """Invalid state machine transition."""
    def __init__(self, from_state: str, to_state: str):
        super().__init__(f"Invalid transition: {from_state} -> {to_state}")
        self.from_state = from_state
        self.to_state = to_state
```

Note on Pydantic: per product decision, `Pydantic ValidationError passes through unchanged —
not wrapped in ConfigError`. This means code should NOT catch ValidationError and re-raise as
ConfigError. The hierarchy above is for llenergymeasure's own errors only.

**Rewrite protocols.py** with the 5 DI interfaces for v2.0:

All 5 must be `@runtime_checkable` Protocol classes. Use TYPE_CHECKING imports for v2.0
types that don't exist yet (ExperimentConfig, ExperimentResult) — these will be created
in Phase 2 and Phase 6. Use string annotations (quotes) for forward references.

```python
@runtime_checkable
class ModelLoader(Protocol):
    def load(self, config: "ExperimentConfig") -> tuple[Any, Any]:
        """Load model and tokenizer. Returns (model, tokenizer)."""
        ...

@runtime_checkable
class InferenceEngine(Protocol):
    def run(self, model: Any, tokenizer: Any, prompts: list[str],
            config: "ExperimentConfig") -> Any:
        """Run inference on prompts. Returns backend-specific result."""
        ...

@runtime_checkable
class MetricsCollector(Protocol):
    def collect(self, model: Any, inference_result: Any,
                config: "ExperimentConfig") -> Any:
        """Collect metrics from inference. Returns metrics object."""
        ...

@runtime_checkable
class EnergyBackend(Protocol):
    @property
    def name(self) -> str: ...
    def start_tracking(self) -> Any: ...
    def stop_tracking(self, tracker: Any) -> Any: ...
    def is_available(self) -> bool: ...

@runtime_checkable
class ResultsRepository(Protocol):
    def save(self, result: "ExperimentResult", output_dir: Path) -> Path: ...
    def load(self, path: Path) -> "ExperimentResult": ...
```

Use `from __future__ import annotations` for clean forward references. Keep TYPE_CHECKING
imports for ExperimentConfig and ExperimentResult pointing to their future locations:
- `from llenergymeasure.config.models import ExperimentConfig` (Phase 2)
- `from llenergymeasure.domain.experiment import ExperimentResult` (Phase 6)

The exact signatures may evolve in later phases, but the Protocol names and their purpose
must be stable.
  </action>
  <verify>
Run: `python -c "from llenergymeasure.exceptions import LLEMError, ConfigError, BackendError, PreFlightError, ExperimentError, StudyError, InvalidStateTransitionError; assert issubclass(ConfigError, LLEMError); assert issubclass(InvalidStateTransitionError, ExperimentError); print('OK')"` — prints OK.
Run: `python -c "from llenergymeasure.protocols import ModelLoader, InferenceEngine, MetricsCollector, EnergyBackend, ResultsRepository; print('All 5 protocols imported')"` — prints message.
  </verify>
  <done>
exceptions.py has LLEMError with 5 direct subclasses (ConfigError, BackendError, PreFlightError, ExperimentError, StudyError) plus InvalidStateTransitionError under ExperimentError. protocols.py has 5 runtime-checkable Protocol classes. Old v1.x names are gone.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite resilience.py and security.py as clean carry-forwards</name>
  <files>
    src/llenergymeasure/resilience.py
    src/llenergymeasure/security.py
  </files>
  <action>
**Rewrite resilience.py** (INF-18 carry-forward):

Keep the `retry_on_error` decorator — it is well-written and correct. Update it to:
1. Import from the new exception hierarchy: `from llenergymeasure.exceptions import LLEMError`
   (not the old `RetryableError` which no longer exists).
2. Default `exceptions` parameter to `(LLEMError,)` instead of `(RetryableError,)`.
3. Remove `cleanup_gpu_memory()` — this is torch-specific and belongs in the PyTorch backend
   (Phase 4), not in a base infrastructure module. The base package has no torch dependency.
4. Remove `safe_cleanup()` — unused wrapper, not needed.
5. Replace loguru with stdlib logging: `import logging; logger = logging.getLogger(__name__)`.
   loguru is not a base dependency in v2.0.

The decorator signature stays the same:
```python
def retry_on_error(
    max_retries: int = 3,
    delay_seconds: float = 1.0,
    backoff_factor: float = 2.0,
    exceptions: tuple[type[Exception], ...] = (LLEMError,),
) -> Callable[[Callable[..., T]], Callable[..., T]]:
```

**Rewrite security.py** (INF-20 carry-forward):

Keep path sanitisation functions. Update:
1. Import from new exceptions: `from llenergymeasure.exceptions import ConfigError`
   (not old `ConfigurationError`).
2. Keep: `validate_path()`, `is_safe_path()`, `sanitize_experiment_id()`.
3. Remove: `check_env_for_secrets()` — dead utility, never used.
4. No other changes needed — these functions are well-written and use only stdlib (pathlib, os).
  </action>
  <verify>
Run: `python -c "from llenergymeasure.resilience import retry_on_error; print(type(retry_on_error))"` — prints function type.
Run: `python -c "from llenergymeasure.security import validate_path, is_safe_path, sanitize_experiment_id; print('OK')"` — prints OK.
Run: `python -c "import ast; tree = ast.parse(open('src/llenergymeasure/resilience.py').read()); imports = [n for n in ast.walk(tree) if isinstance(n, ast.ImportFrom) and n.module and 'loguru' in n.module]; assert len(imports) == 0, 'loguru import found'; print('No loguru dependency')"` — confirms no loguru.
  </verify>
  <done>
resilience.py has retry_on_error using new LLEMError hierarchy, no torch/loguru deps. security.py has validate_path, is_safe_path, sanitize_experiment_id using new ConfigError, no dead functions. Both modules depend only on stdlib + llenergymeasure.exceptions.
  </done>
</task>

</tasks>

<verification>
1. All 5 protocol classes importable from protocols.py
2. All 6 exception classes importable from exceptions.py (LLEMError + 5 subclasses)
3. InvalidStateTransitionError is a subclass of ExperimentError
4. resilience.py has no loguru or torch imports
5. security.py has no dead functions (check_env_for_secrets removed)
6. All modules use only base dependencies (stdlib + pydantic at most)
</verification>

<success_criteria>
- protocols.py: 5 @runtime_checkable Protocol classes with v2.0 signatures
- exceptions.py: LLEMError -> ConfigError, BackendError, PreFlightError, ExperimentError, StudyError
- resilience.py: retry_on_error with exponential backoff, no torch/loguru
- security.py: path validation only, no dead code
</success_criteria>

<output>
After completion, create `.planning/phases/01-measurement-foundations/01-02-SUMMARY.md`
</output>
