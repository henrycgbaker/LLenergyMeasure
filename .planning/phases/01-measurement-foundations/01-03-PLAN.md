---
phase: 01-measurement-foundations
plan: 03
type: execute
wave: 2
depends_on:
  - 01-02
files_modified:
  - src/llenergymeasure/core/state.py
  - src/llenergymeasure/state/experiment_state.py
  - src/llenergymeasure/infra/subprocess.py
  - src/llenergymeasure/cli/lifecycle.py
  - src/llenergymeasure/orchestration/lifecycle.py
autonomous: true
requirements:
  - INF-07
  - INF-08
  - INF-19

must_haves:
  truths:
    - "State machine has exactly 3 states: INITIALISING, MEASURING, DONE"
    - "State machine has a failed:bool flag orthogonal to the 3 states"
    - "StateManager persists state atomically (write-to-temp-then-rename)"
    - "find_by_config_hash() locates incomplete experiments by config hash"
    - "cleanup_stale() marks abandoned MEASURING states as failed"
    - "Subprocess lifecycle carry-forward provides signal handling and process group management"
  artifacts:
    - path: "src/llenergymeasure/core/state.py"
      provides: "3-state machine with StateManager"
      contains: "INITIALISING"
    - path: "src/llenergymeasure/infra/subprocess.py"
      provides: "Subprocess lifecycle management"
      contains: "SubprocessRunner"
  key_links:
    - from: "src/llenergymeasure/core/state.py"
      to: "src/llenergymeasure/exceptions.py"
      via: "imports InvalidStateTransitionError"
      pattern: "from llenergymeasure\\.exceptions import"
    - from: "src/llenergymeasure/core/state.py"
      to: "src/llenergymeasure/security.py"
      via: "imports sanitize_experiment_id for safe file paths"
      pattern: "from llenergymeasure\\.security import"
    - from: "src/llenergymeasure/infra/subprocess.py"
      to: "src/llenergymeasure/core/state.py"
      via: "imports ExperimentState for interrupt handling"
      pattern: "from llenergymeasure\\.core\\.state import"
---

<objective>
Create the v2.0 3-state machine in core/state.py (replacing the 6-state v1.x version),
implement StateManager with atomic persistence, and carry-forward subprocess lifecycle
management into a clean infra/ module.

Purpose: The state machine tracks experiment lifecycle for resume and dedup. The subprocess
runner provides graceful shutdown. Both are used by the runner in Phase 3+.
Output: core/state.py with 3-state machine + StateManager, infra/subprocess.py with SubprocessRunner.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-measurement-foundations/01-02-SUMMARY.md
@src/llenergymeasure/state/experiment_state.py
@src/llenergymeasure/cli/lifecycle.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 3-state machine in core/state.py</name>
  <files>
    src/llenergymeasure/core/state.py
    src/llenergymeasure/state/experiment_state.py
  </files>
  <action>
**Create src/llenergymeasure/core/state.py** — the v2.0 state machine (INF-07, INF-08).

The v1.x has 6 states (INITIALISED, RUNNING, COMPLETED, AGGREGATED, FAILED, INTERRUPTED).
The v2.0 requirement is 3 states + a `failed: bool` flag:

```python
class ExperimentPhase(str, Enum):
    INITIALISING = "initialising"
    MEASURING = "measuring"
    DONE = "done"
```

Valid transitions:
```
INITIALISING -> MEASURING (experiment starts running)
MEASURING -> DONE (experiment completes successfully)
```
The `failed` flag is orthogonal — any phase can have `failed=True`. When an experiment
fails during MEASURING, the state stays MEASURING with `failed=True`. This simplifies
the old 6-state machine dramatically.

**ExperimentState model** (Pydantic BaseModel with `model_config = {"extra": "forbid"}`):
- experiment_id: str
- phase: ExperimentPhase (default INITIALISING)
- failed: bool (default False)
- config_hash: str | None (for find_by_config_hash)
- error_message: str | None
- started_at: datetime | None
- last_updated: datetime (auto-set)
- subprocess_pid: int | None (for stale detection)

Methods:
- `transition_to(new_phase: ExperimentPhase)`: validates transition, raises InvalidStateTransitionError if invalid
- `mark_failed(error: str)`: sets failed=True and error_message
- `can_transition_to(new_phase) -> bool`
- `is_subprocess_running() -> bool` (check PID, carry-forward from v1.x)

**StateManager class** (INF-08):
- `__init__(state_dir: Path | None = None)`: defaults to platformdirs user_state_path
- `load(experiment_id: str) -> ExperimentState | None`
- `save(state: ExperimentState) -> Path`: atomic write (temp file then rename)
- `create(experiment_id: str, config_hash: str | None = None) -> ExperimentState`
- `delete(experiment_id: str) -> bool`
- `find_by_config_hash(config_hash: str) -> ExperimentState | None`: finds incomplete experiments matching hash
- `cleanup_stale() -> list[str]`: marks MEASURING states where subprocess PID is dead as failed
- `list_experiments() -> list[str]`

**compute_config_hash(config_dict: dict) -> str** — keep the existing implementation
(SHA-256, 16 chars, excludes volatile fields).

Import from v2.0 modules:
- `from llenergymeasure.exceptions import InvalidStateTransitionError, ConfigError`
- `from llenergymeasure.security import sanitize_experiment_id, is_safe_path`

Use `platformdirs.user_state_path("llenergymeasure")` for default state dir instead of
hardcoded ".state". Import platformdirs (it is a base dependency per INF-02).

Use stdlib logging, NOT loguru.

**Delete the old state module:**
- Delete `src/llenergymeasure/state/experiment_state.py`
- Keep the `src/llenergymeasure/state/` directory as-is for now (it may have __init__.py).
  Or if state/ only contained experiment_state.py, delete the directory entirely and
  ensure no imports reference it. The new location is `core/state.py`.
  </action>
  <verify>
Run: `python -c "
from llenergymeasure.core.state import ExperimentPhase, ExperimentState, StateManager, compute_config_hash
# Verify 3 states
assert len(ExperimentPhase) == 3
assert ExperimentPhase.INITIALISING.value == 'initialising'
assert ExperimentPhase.MEASURING.value == 'measuring'
assert ExperimentPhase.DONE.value == 'done'
# Verify failed flag
s = ExperimentState(experiment_id='test')
assert s.failed == False
s.mark_failed('boom')
assert s.failed == True
assert s.error_message == 'boom'
# Verify transitions
s2 = ExperimentState(experiment_id='test2')
s2.transition_to(ExperimentPhase.MEASURING)
assert s2.phase == ExperimentPhase.MEASURING
s2.transition_to(ExperimentPhase.DONE)
assert s2.phase == ExperimentPhase.DONE
# Verify invalid transition raises
from llenergymeasure.exceptions import InvalidStateTransitionError
s3 = ExperimentState(experiment_id='test3')
try:
    s3.transition_to(ExperimentPhase.DONE)
    assert False, 'Should have raised'
except InvalidStateTransitionError:
    pass
print('All state machine checks passed')
"` — prints message.
  </verify>
  <done>
core/state.py has ExperimentPhase with 3 states (INITIALISING, MEASURING, DONE), ExperimentState with failed:bool flag, StateManager with find_by_config_hash() and cleanup_stale() and atomic persistence. Old state/experiment_state.py deleted.
  </done>
</task>

<task type="auto">
  <name>Task 2: Carry-forward subprocess lifecycle into infra/subprocess.py</name>
  <files>
    src/llenergymeasure/infra/__init__.py
    src/llenergymeasure/infra/subprocess.py
    src/llenergymeasure/cli/lifecycle.py
    src/llenergymeasure/orchestration/lifecycle.py
  </files>
  <action>
**Create src/llenergymeasure/infra/ package** with __init__.py.

**Create src/llenergymeasure/infra/subprocess.py** — carry-forward from cli/lifecycle.py (INF-19):

Extract the `SubprocessRunner` class from `src/llenergymeasure/cli/lifecycle.py` into the
new location. This is the subprocess lifecycle manager with signal handling, process group
management, and graceful shutdown.

Key changes from the v1.x version:
1. Remove Rich console dependency — use stdlib print for interrupt messages.
2. Remove Typer dependency — raise SystemExit(130) instead of typer.Exit(130).
3. Import from v2.0 state module: `from llenergymeasure.core.state import ExperimentState, ExperimentPhase, StateManager`
4. When handling interrupt, set `state.mark_failed("Interrupted by user")` instead of
   transitioning to INTERRUPTED status (which no longer exists in the 3-state machine).
5. Use stdlib logging instead of loguru.

Keep these helper functions (useful for Phase 4+):
- `build_subprocess_env(backend: str, gpus: list[int], verbosity: str | None = None) -> dict[str, str]`

Remove (dead/campaign-specific):
- `build_pytorch_launch_cmd()` — will be rebuilt in Phase 4 if needed
- `build_vllm_launch_cmd()` — will be rebuilt when vLLM support is added

**Delete the old files:**
- Delete `src/llenergymeasure/cli/lifecycle.py` (moved to infra/)
- Delete `src/llenergymeasure/orchestration/lifecycle.py` (torch-specific, belongs in Phase 4)

**Update any remaining imports** in files that import from these old locations.
Search for `from llenergymeasure.cli.lifecycle import` and
`from llenergymeasure.orchestration.lifecycle import` — if any still-existing files
reference them, update the import paths. (Most importers should have been deleted in Plan 01.)
  </action>
  <verify>
Run: `python -c "from llenergymeasure.infra.subprocess import SubprocessRunner; print('SubprocessRunner imported')"` — prints message.
Run: `python -c "import ast; tree = ast.parse(open('src/llenergymeasure/infra/subprocess.py').read()); imports = [n.module for n in ast.walk(tree) if isinstance(n, ast.ImportFrom) and n.module]; assert not any('typer' in m for m in imports), 'typer found'; assert not any('loguru' in m for m in imports), 'loguru found'; print('No typer/loguru deps')"` — prints message.
Run: `test ! -f src/llenergymeasure/cli/lifecycle.py && echo 'old lifecycle deleted'` — prints message.
  </verify>
  <done>
infra/subprocess.py has SubprocessRunner with signal handling and process group management, using v2.0 state module and stdlib logging. Old cli/lifecycle.py and orchestration/lifecycle.py deleted. No typer/loguru/Rich dependencies in the new module.
  </done>
</task>

</tasks>

<verification>
1. `from llenergymeasure.core.state import ExperimentPhase` — has exactly 3 members
2. `ExperimentState.failed` defaults to False, `mark_failed()` sets it to True
3. `StateManager` has `find_by_config_hash()`, `cleanup_stale()`, atomic `save()`
4. `SubprocessRunner` handles SIGINT/SIGTERM with graceful shutdown
5. Old state/ and lifecycle files are deleted
6. No loguru, typer, or Rich imports in any new module
</verification>

<success_criteria>
- core/state.py: 3-state machine (INITIALISING, MEASURING, DONE) with failed:bool
- StateManager: atomic persistence, find_by_config_hash, cleanup_stale
- infra/subprocess.py: SubprocessRunner with signal handling, no CLI deps
- Old v1.x state and lifecycle modules deleted
</success_criteria>

<output>
After completion, create `.planning/phases/01-measurement-foundations/01-03-SUMMARY.md`
</output>
