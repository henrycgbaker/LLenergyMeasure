# Phase 2.1: Zero-Config Install Experience - Research

**Researched:** 2026-01-30
**Domain:** Python packaging, pip install hooks, Docker runtime detection, CLI design
**Confidence:** HIGH

## Summary

Zero-config install experience requires coordinating five technical domains: (1) Python packaging with default extras for PyTorch, (2) runtime detection to distinguish local Python installs from Docker containers, (3) on-demand .env generation for Docker mode, (4) optional dependency checking for backend selection, and (5) CLI subcommand design for Docker lifecycle management.

The research reveals a critical insight: **post-install hooks don't work with editable installs** (`pip install -e .`), which is the primary development workflow. Instead, zero-config is achieved through **first-run detection** within the CLI itself, combined with smart runtime detection to avoid misidentifying conda/venv as Docker contexts.

The current `_should_use_docker()` implementation is broken — it returns `False` in all cases, which defeats multi-backend campaign orchestration. The fix requires distinguishing three execution contexts: (1) inside Docker container (no dispatch), (2) local Python install (no Docker needed for single backend), (3) host with Docker available (dispatch to containers for multi-backend campaigns).

**Primary recommendation:** Use Poetry extras with PyTorch as default dependencies, add `lem docker setup` CLI subcommand for guided Docker configuration, implement first-run .env generation on first Docker operation, and replace `_should_use_docker()` with multi-context detection.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Poetry | >=1.8 | Packaging, dependency management | Industry standard for modern Python projects, supports PEP 621 |
| Typer | >=0.15.0 | CLI framework (already in use) | Rich integration, nested subcommands, type-safe |
| python-dotenv | >=1.0.0 | .env file loading (already in use) | De facto standard for environment variable management |
| python-on-whales | >=0.70 | Docker orchestration (already in use) | Pythonic docker-compose API, already used in Phase 2 |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| importlib.util | stdlib | Runtime import checking | Detect if backend packages are importable |
| os / sys | stdlib | Environment/path detection | Check for virtualenv, Docker, PUID/PGID |
| pathlib | stdlib | File operations | Check for .env existence, /.dockerenv marker |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Poetry | Setuptools + pip | Poetry provides better dev workflow; setuptools is lower-level but more universal for distribution |
| python-dotenv | os.environ directly | dotenv provides .env file loading; direct os.environ requires manual parsing |
| Typer nested commands | Click groups | Typer is already in use and provides better type safety; Click is more low-level |

**Installation:**
```bash
# Current (already satisfied)
poetry add python-dotenv typer python-on-whales

# No new dependencies needed for Phase 2.1
```

## Architecture Patterns

### Recommended Project Structure
```
src/llenergymeasure/
├── cli/
│   ├── __init__.py          # Main app, command registration
│   ├── docker.py            # NEW: `lem docker` subcommand group
│   ├── experiment.py        # Existing experiment commands
│   ├── campaign.py          # Contains broken _should_use_docker()
│   └── ...
├── config/
│   └── docker_detection.py  # NEW: Refactored runtime detection logic
└── ...
pyproject.toml               # Define extras, default dependencies
.env                         # Auto-generated (PUID/PGID only)
Makefile                     # Update targets: remove setup.sh refs, add docker-setup
```

### Pattern 1: Poetry Extras with Default Backend

**What:** Define PyTorch as part of base dependencies, other backends as optional extras.

**When to use:** For packages where one backend covers 90% of use cases and should "just work" on install.

**Example:**
```toml
# pyproject.toml
[tool.poetry.dependencies]
python = "^3.10"
torch = "^2.5.0"                    # PyTorch moves from optional to core
transformers = "^4.49.0"
accelerate = "^1.4.0"               # PyTorch ecosystem as default
bitsandbytes = "^0.45.0"
# ... other core deps

# Optional backends remain extras
vllm = {version = ">=0.6.0", optional = true}
tensorrt-llm = {version = ">=0.12.0", optional = true}

[tool.poetry.extras]
vllm = ["vllm"]
tensorrt = ["tensorrt-llm"]
dev = ["pytest", "ruff", "mypy", ...]
```

**Why this works:**
- `pip install llenergymeasure` installs core + PyTorch → works immediately
- `pip install llenergymeasure[vllm]` adds vLLM on top
- Development: `poetry install` installs everything in main dependencies
- Aligns with PEP 621 optional-dependencies (Poetry 2.0+ supports `[project]` table)

**Source:** [Poetry dependency management](https://python-poetry.org/docs/managing-dependencies/)

### Pattern 2: Runtime Backend Detection via Optional Imports

**What:** Check if a backend package is importable at runtime using try/except ImportError pattern.

**When to use:** When validating backend availability before experiment execution, or for `lem backend list` command.

**Example:**
```python
# src/llenergymeasure/config/backend_detection.py
from typing import Literal

BackendName = Literal["pytorch", "vllm", "tensorrt"]

def is_backend_available(backend: BackendName) -> bool:
    """Check if a backend package can be imported.

    Returns:
        True if backend is installed and importable, False otherwise.
    """
    try:
        if backend == "pytorch":
            import torch  # noqa: F401
            return True
        elif backend == "vllm":
            import vllm  # noqa: F401
            return True
        elif backend == "tensorrt":
            import tensorrt_llm  # noqa: F401
            return True
    except ImportError:
        return False
    return False

def get_available_backends() -> list[BackendName]:
    """Get list of all installed backends."""
    return [b for b in ["pytorch", "vllm", "tensorrt"] if is_backend_available(b)]
```

**Type checking caveat:** Mypy complains about assigning None to module-typed variables. Workaround: import inside functions or use `# type: ignore`.

**Source:** [Python type hints - optional imports (Adam Johnson)](https://adamj.eu/tech/2021/12/29/python-type-hints-optional-imports/)

### Pattern 3: Multi-Context Runtime Detection

**What:** Distinguish between three execution contexts: (1) inside Docker, (2) local Python (conda/venv/poetry), (3) host with Docker.

**When to use:** Campaign mode needs to decide whether to dispatch to Docker containers.

**Example:**
```python
# src/llenergymeasure/config/docker_detection.py
import os
import sys
from pathlib import Path

def is_inside_docker() -> bool:
    """Check if currently running inside a Docker container.

    Uses two detection methods:
    1. /.dockerenv file (Docker creates this in containers)
    2. /proc/1/cgroup containing "docker" or "containerd"

    Returns:
        True if running inside Docker container, False otherwise.
    """
    # Method 1: Check for /.dockerenv marker file
    if Path("/.dockerenv").exists():
        return True

    # Method 2: Check /proc/1/cgroup for container runtime
    try:
        cgroup_content = Path("/proc/1/cgroup").read_text()
        if "docker" in cgroup_content or "containerd" in cgroup_content:
            return True
    except (FileNotFoundError, PermissionError):
        # /proc not available (Windows, macOS) or permission denied
        pass

    return False

def is_local_python_install() -> bool:
    """Check if running from a local Python install (venv, conda, poetry).

    Returns:
        True if in virtualenv/conda, False if system Python or inside Docker.
    """
    # Check virtualenv (venv, virtualenv)
    if sys.prefix != sys.base_prefix:
        return True

    # Check conda environment
    if "CONDA_DEFAULT_ENV" in os.environ:
        return True

    # Check if lem is installed locally (importable)
    # This covers poetry install cases
    try:
        import llenergymeasure  # noqa: F401
        return True
    except ImportError:
        return False

def should_use_docker_for_campaign(backends: list[str]) -> bool:
    """Determine if campaign should dispatch to Docker containers.

    Decision logic:
    1. If inside Docker → no (already in container)
    2. If local install with single backend → no (run locally)
    3. If local install with multiple backends → yes (Docker isolation)
    4. If no local install → yes (assume Docker-first setup)

    Args:
        backends: List of backend names the campaign uses

    Returns:
        True if should use Docker dispatch, False if run locally.
    """
    # Already inside Docker → no nested containers
    if is_inside_docker():
        return False

    # Single backend → prefer local execution if available
    if len(backends) == 1:
        backend = backends[0]
        if is_local_python_install() and is_backend_available(backend):
            return False  # Run locally

    # Multi-backend OR backend not installed locally → use Docker
    return True
```

**Critical fix:** This replaces the broken `_should_use_docker()` which always returned False.

**Sources:**
- [Detecting Docker containers (DEV Community)](https://dev.to/serhatteker/how-to-check-if-a-docker-container-running-with-python-3aoj)
- [Virtualenv detection (GeeksforGeeks)](https://www.geeksforgeeks.org/python/determining-if-python-is-running-in-a-virtualenv/)

### Pattern 4: First-Run .env Generation

**What:** Auto-generate .env file on first Docker operation, not at pip install time.

**When to use:** When post-install hooks are unavailable (editable installs) or undesirable (explicit user action preferred).

**Example:**
```python
# src/llenergymeasure/config/env_setup.py
import os
from pathlib import Path
from loguru import logger

def ensure_env_file(project_root: Path | None = None) -> Path:
    """Ensure .env file exists with PUID/PGID for Docker.

    Auto-generates .env if missing, logs once on creation.
    Silently succeeds if .env already exists.

    Args:
        project_root: Project root directory (default: infer from cwd)

    Returns:
        Path to .env file
    """
    if project_root is None:
        # Infer project root (directory containing pyproject.toml or .git)
        current = Path.cwd()
        while current != current.parent:
            if (current / "pyproject.toml").exists() or (current / ".git").exists():
                project_root = current
                break
            current = current.parent
        else:
            project_root = Path.cwd()  # Fallback to cwd

    env_file = project_root / ".env"

    if env_file.exists():
        return env_file

    # Generate .env with PUID/PGID
    puid = os.getuid()  # Unix only - Docker only runs on Linux anyway
    pgid = os.getgid()

    env_content = f"""# Auto-generated by llenergymeasure
# Docker user mapping for correct file ownership
PUID={puid}
PGID={pgid}
"""

    env_file.write_text(env_content)
    logger.info(f"Generated .env with PUID={puid} PGID={pgid} for Docker")

    return env_file
```

**Call site:** Invoke from `lem docker setup` command and at start of `campaign_cmd` if Docker mode detected.

**Why first-run, not post-install:**
- Post-install hooks (`setuptools.command.install`) don't fire for `pip install -e .` ([setuptools issue #1789](https://github.com/pypa/setuptools/issues/1789))
- Editable installs are the primary development workflow
- First-run detection is more explicit and debuggable

### Pattern 5: Typer Nested Subcommands

**What:** Create a separate Typer app for `docker` subcommands, add to main app.

**When to use:** When logically grouping related commands (`lem docker setup`, `lem docker build`, `lem docker status`).

**Example:**
```python
# src/llenergymeasure/cli/docker.py
"""Docker lifecycle management commands."""

from typing import Annotated
import typer
from llenergymeasure.cli.display import console

docker_app = typer.Typer(
    name="docker",
    help="Docker setup and management",
)

@docker_app.command("setup")
def docker_setup_cmd(
    backends: Annotated[
        list[str] | None,
        typer.Option("--backend", "-b", help="Backends to build (default: pytorch)"),
    ] = None,
) -> None:
    """Set up Docker environment for multi-backend campaigns.

    Interactive setup:
    - Checks Docker and NVIDIA Container Toolkit availability
    - Generates .env file with PUID/PGID
    - Builds selected backend images
    - Verifies GPU access
    """
    from llenergymeasure.config.env_setup import ensure_env_file
    from llenergymeasure.config.docker_detection import is_inside_docker

    if is_inside_docker():
        console.print("[yellow]Already inside Docker - setup not needed[/yellow]")
        raise typer.Exit(1)

    backends = backends or ["pytorch"]

    # Check Docker available
    import shutil
    if not shutil.which("docker"):
        console.print("[red]Error: Docker not found[/red]")
        console.print("Install from: https://docs.docker.com/get-docker/")
        raise typer.Exit(1)

    # Generate .env
    ensure_env_file()
    console.print("[green]✓[/green] .env configured")

    # Build images
    for backend in backends:
        console.print(f"Building {backend} image...")
        # Implementation: subprocess docker compose build

    console.print("[green]✓[/green] Docker setup complete")

@docker_app.command("status")
def docker_status_cmd() -> None:
    """Show Docker environment status."""
    # Check Docker, NVIDIA CTK, .env, built images
    pass

@docker_app.command("build")
def docker_build_cmd(
    backend: Annotated[str, typer.Argument(help="Backend to build")],
) -> None:
    """Build a specific backend Docker image."""
    pass
```

**Registration in main app:**
```python
# src/llenergymeasure/cli/__init__.py
from llenergymeasure.cli.docker import docker_app

app.add_typer(docker_app, name="docker")
```

**Source:** [Typer nested subcommands](https://typer.tiangolo.com/tutorial/subcommands/nested-subcommands/)

### Anti-Patterns to Avoid

- **Post-install hooks for editable installs:** Don't rely on `setuptools.command.install` — it doesn't fire for `pip install -e .`
- **Checking /.dockerenv only:** Podman uses `/run/.containerenv`; use multiple detection methods
- **Checking /proc/1/cgroup on cgroup v2:** May only show `0::/` inside containers; combine with /.dockerenv check
- **Setting module = None on ImportError:** Mypy complains about type incompatibility; import inside functions instead
- **Global .env with HF_TOKEN:** Security risk; use `huggingface-cli login` and bind-mount `~/.cache/huggingface/token`

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Environment variable management | Custom .env parser | python-dotenv | Already in use, handles escaping, comments, multiline |
| Docker container orchestration | Subprocess docker calls | python-on-whales | Already in use (Phase 2), type-safe API, better error handling |
| CLI argument parsing | argparse | Typer | Already in use, type-safe, auto-generates help, nested commands |
| User/group ID detection | Parse /etc/passwd | os.getuid() / os.getgid() | Stdlib, handles edge cases, works with NFS uid mapping |
| Virtual environment detection | Check VIRTUAL_ENV var only | sys.prefix != sys.base_prefix | Documented approach, works across venv/virtualenv, doesn't rely on env vars |

**Key insight:** The project already has the right dependencies. Phase 2.1 is about **refactoring existing patterns**, not adding new libraries.

## Common Pitfalls

### Pitfall 1: Post-Install Hooks for .env Generation

**What goes wrong:** Using setuptools `install` command or Poetry scripts to auto-generate .env on `pip install`.

**Why it happens:** Developers assume post-install hooks work like npm's `postinstall`. They don't.

**How to avoid:** Use **first-run detection** inside the CLI. Check for .env existence at start of Docker operations, generate if missing.

**Warning signs:**
- `pip install -e .` doesn't generate .env but `pip install .` does
- Users report "missing .env" errors on first run
- CI fails because .env generation requires interactive install

**Source:** [setuptools issue #1789 - post install doesn't work in editable mode](https://github.com/pypa/setuptools/issues/1789)

### Pitfall 2: Conda/Venv Misidentified as Docker Context

**What goes wrong:** Logic checks "is lem installed?" and concludes "no Docker needed", but campaign has multiple backends, some not installed locally.

**Why it happens:** Current `_should_use_docker()` returns False if lem is importable, regardless of whether all required backends are available.

**How to avoid:** Check **both** install context (Docker vs local) **and** backend availability. Multi-backend campaigns need Docker isolation even with local lem install.

**Warning signs:**
- Campaign with vLLM + TensorRT fails on conda install of PyTorch-only
- Error: "vllm module not found" when running campaign
- Works in Docker but fails in local conda

**Detection logic:**
```python
# WRONG (current implementation)
def _should_use_docker():
    if can_import_llenergymeasure():
        return False  # ❌ Assumes all backends available
    return True

# RIGHT (proposed fix)
def should_use_docker_for_campaign(backends: list[str]):
    if is_inside_docker():
        return False
    if len(backends) == 1 and is_backend_available(backends[0]):
        return False  # Single backend, locally available
    return True  # Multi-backend or backend not installed
```

### Pitfall 3: Silent .env Overwrites

**What goes wrong:** Auto-generating .env without checking if it exists, wiping user customisations (e.g., manually added HF_TOKEN).

**Why it happens:** First-run detection doesn't check file existence, or setup script defaults to overwrite.

**How to avoid:** **Check if .env exists before writing.** If exists, skip generation silently (log at debug level).

**Warning signs:**
- User reports "HF_TOKEN keeps disappearing"
- .env file datestamp changes on every run
- Git shows .env as modified after innocent operations

**Safe implementation:**
```python
def ensure_env_file(project_root: Path) -> Path:
    env_file = project_root / ".env"
    if env_file.exists():
        return env_file  # ✓ Don't overwrite

    # Generate only if missing
    env_file.write_text(generate_env_content())
    logger.info("Generated .env")  # ✓ Log once
    return env_file
```

### Pitfall 4: Docker Detection False Positives

**What goes wrong:** Checking only /.dockerenv fails in Podman, checking only /proc/1/cgroup fails with cgroup v2.

**Why it happens:** Docker detection logic assumes Docker-specific implementation details that vary across container runtimes and kernel versions.

**How to avoid:** Use **multiple detection methods** with OR logic. If any method detects container, assume container.

**Warning signs:**
- Works in Docker, fails in Podman
- Works on Ubuntu 20.04, fails on Ubuntu 22.04 (cgroup v2)
- Works when run with `docker run`, fails with `docker compose`

**Robust detection:**
```python
def is_inside_docker() -> bool:
    # Method 1: Docker marker file
    if Path("/.dockerenv").exists():
        return True

    # Method 2: cgroup inspection (works with Docker, containerd)
    try:
        cgroup = Path("/proc/1/cgroup").read_text()
        if "docker" in cgroup or "containerd" in cgroup:
            return True
    except (FileNotFoundError, PermissionError):
        pass  # /proc not available (Windows/macOS)

    # Could add Method 3: check for container-specific env vars
    # if "KUBERNETES_SERVICE_HOST" in os.environ:
    #     return True

    return False
```

**Source:** [Docker community discussion on container detection](https://forums.docker.com/t/detect-you-are-running-in-a-docker-container-buildx/139673)

### Pitfall 5: Hardcoded Backend Lists

**What goes wrong:** CLI commands or validation logic have hardcoded `["pytorch", "vllm", "tensorrt"]` lists that become stale when backends are added/removed.

**Why it happens:** Convenience — easier to write a list than introspect pyproject.toml or backend registry.

**How to avoid:** **Derive backend list from runtime checks or config metadata.** Use `get_available_backends()` function, not hardcoded lists.

**Warning signs:**
- Add new backend extra in pyproject.toml, but `lem backend list` doesn't show it
- Backend validation rejects valid backend name
- Maintenance burden: update backend list in 5+ places per new backend

**SSOT approach:**
```python
# Define once
KNOWN_BACKENDS = ["pytorch", "vllm", "tensorrt"]

# Use everywhere
def get_available_backends() -> list[str]:
    return [b for b in KNOWN_BACKENDS if is_backend_available(b)]
```

Better: Introspect pyproject.toml extras at runtime (higher complexity, perfect SSOT).

## Code Examples

Verified patterns from official sources:

### Check Virtual Environment (stdlib)
```python
# Source: https://docs.python.org/3/library/sys.html#sys.prefix
import sys

def in_virtualenv() -> bool:
    """Check if running in a virtual environment (venv, virtualenv).

    Returns:
        True if in virtualenv, False if system Python.
    """
    return sys.prefix != sys.base_prefix
```

### Check Conda Environment
```python
# Source: https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html
import os

def in_conda_env() -> bool:
    """Check if running in a conda environment.

    Returns:
        True if in conda environment, False otherwise.
    """
    return "CONDA_DEFAULT_ENV" in os.environ
```

### Get PUID/PGID (stdlib)
```python
# Source: https://docs.python.org/3/library/os.html#os.getuid
import os

def get_docker_user_mapping() -> tuple[int, int]:
    """Get current user/group IDs for Docker user mapping.

    Returns:
        Tuple of (PUID, PGID) for use in Docker environment.

    Note:
        Unix-only. Docker only runs on Linux anyway.
    """
    return os.getuid(), os.getgid()
```

### Typer Nested Subcommands
```python
# Source: https://typer.tiangolo.com/tutorial/subcommands/
import typer

# Create sub-app for docker commands
docker_app = typer.Typer(help="Docker lifecycle management")

@docker_app.command("setup")
def docker_setup() -> None:
    """Set up Docker environment."""
    pass

@docker_app.command("status")
def docker_status() -> None:
    """Show Docker status."""
    pass

# Add to main app
app = typer.Typer()
app.add_typer(docker_app, name="docker")

# Usage: lem docker setup, lem docker status
```

### Optional Import with Fallback
```python
# Source: https://mharty3.github.io/til/python/optional-imports/
try:
    import vllm
    VLLM_AVAILABLE = True
except ImportError:
    VLLM_AVAILABLE = False

def run_vllm_inference():
    if not VLLM_AVAILABLE:
        raise RuntimeError(
            "vLLM backend not installed.\n"
            "Install with: pip install llenergymeasure[vllm]"
        )
    # Use vllm
```

### Poetry Extras Definition
```toml
# Source: https://python-poetry.org/docs/pyproject/
[tool.poetry.dependencies]
python = "^3.10"
torch = "^2.5.0"  # Default backend in core deps

vllm = {version = ">=0.6.0", optional = true}
tensorrt-llm = {version = ">=0.12.0", optional = true}

[tool.poetry.extras]
vllm = ["vllm"]
tensorrt = ["tensorrt-llm"]
# Install: pip install llenergymeasure[vllm]
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| setup.py with cmdclass | pyproject.toml with Poetry | Poetry 1.0+ (2019), setuptools 61+ (2022) | Pure pyproject.toml builds, no setup.py needed |
| Post-install hooks (setuptools) | First-run detection in CLI | Ongoing (editable installs broke it) | More reliable for dev workflow, explicit user action |
| HF_TOKEN in .env file | huggingface-cli login + bind-mount | 2023+ (HF CLI matured) | Better security, no accidental commits of tokens |
| Docker detection via /.dockerenv only | Multi-method detection | cgroup v2 adoption (~2021+) | Works across container runtimes and kernel versions |
| VIRTUAL_ENV env var check | sys.prefix != sys.base_prefix | Python 3.3+ (venv stdlib) | Documented, works without relying on env vars |

**Deprecated/outdated:**
- `setuptools.command.install` hooks: Don't work with `pip install -e .` since pip 21.3+ ([issue](https://github.com/pypa/setuptools/issues/1789))
- Single-method Docker detection: Podman, cgroup v2 require multi-method approach
- `setup.py` for metadata: Use `pyproject.toml` with Poetry or setuptools >=61
- Hardcoded extras lists: Use introspection or SSOT backend registry

**Emerging (not yet stable):**
- PEP 771 (Default Extras): Draft status as of Jan 2025, not in pip stable yet. Would allow `pip install llenergymeasure` to default to `[pytorch]` extra. **Don't rely on this yet.**

## Open Questions

Things that couldn't be fully resolved:

1. **Should `make docker-setup` exist?**
   - What we know: Phase 2.1 decisions say "add make docker-setup for Docker-only bootstrap"
   - What's unclear: Is this for users who DON'T have Python installed locally? Edge case?
   - Recommendation: Implement as lightweight wrapper: `pip install -e . && lem docker setup`. Useful for CI or Docker-first users.

2. **HF_TOKEN passthrough vs bind-mount**
   - What we know: docker-compose.yml passes `HF_TOKEN=${HF_TOKEN:-}` from environment
   - What's unclear: Does this work if token is in `~/.cache/huggingface/token`?
   - Recommendation: Test both methods. Document recommended approach in deployment guide.

3. **Backend detection error messages**
   - What we know: Should give actionable errors like "Install with: pip install llenergymeasure[vllm]"
   - What's unclear: Should we detect conflicting backends (vllm + tensorrt) and warn?
   - Recommendation: Start with simple missing-backend errors. Add conflict detection if users hit it.

4. **Docker image auto-build vs explicit build**
   - What we know: Phase 2.1 decisions say "no auto-build, too magical"
   - What's unclear: Should `lem campaign` fail with "image not built" or auto-trigger build?
   - Recommendation: Fail fast with actionable error: "Run: lem docker setup --backend pytorch"

5. **Backward compatibility with ./lem wrapper**
   - What we know: Current `./lem` shell script handles Docker dispatch
   - What's unclear: Can we deprecate it in favour of `lem` CLI handling Docker dispatch natively?
   - Recommendation: Keep `./lem` for now (generated by `lem docker setup`), deprecate in Phase 3 after validation.

## Sources

### Primary (HIGH confidence)
- [Typer Nested Subcommands](https://typer.tiangolo.com/tutorial/subcommands/nested-subcommands/) - CLI subcommand pattern
- [Poetry Dependency Management](https://python-poetry.org/docs/managing-dependencies/) - Extras definition
- [Python sys.prefix documentation](https://docs.python.org/3/library/sys.html#sys.prefix) - Virtualenv detection
- [Python os.getuid/getgid](https://docs.python.org/3/library/os.html#os.getuid) - PUID/PGID retrieval
- [setuptools issue #1789](https://github.com/pypa/setuptools/issues/1789) - Post-install hooks broken in editable mode

### Secondary (MEDIUM confidence)
- [Entry Points - setuptools documentation](https://setuptools.pypa.io/en/latest/userguide/entry_point.html) - Console scripts pattern
- [PEP 771 - Default Extras](https://peps.python.org/pep-0771/) - Future default extras (draft, not implemented)
- [Docker container detection (DEV Community)](https://dev.to/serhatteker/how-to-check-if-a-docker-container-running-with-python-3aoj) - Multi-method detection
- [Python type hints - optional imports (Adam Johnson)](https://adamj.eu/tech/2021/12/29/python-type-hints-optional-imports/) - ImportError pattern
- [Python packaging best practices 2026](https://dasroot.net/posts/2026/01/python-packaging-best-practices-setuptools-poetry-hatch/) - Modern packaging landscape

### Tertiary (LOW confidence)
- [WebSearch: Docker detection methods 2026] - cgroup v2 challenges, multiple detection required
- [WebSearch: First-run detection patterns] - No standard library solution, custom implementation needed
- [WebSearch: Makefile Docker patterns] - .PHONY targets, docker-compose integration

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Python-dotenv, Typer, Poetry are established and already in use
- Architecture patterns: HIGH - Poetry extras, Typer nested commands, sys.prefix detection are documented stdlib/official patterns
- Docker detection: MEDIUM - Multiple sources agree on multi-method approach, but edge cases exist (Podman, cgroup v2)
- First-run .env generation: HIGH - Pattern is clear (check existence, generate if missing), stdlib pathlib handles it
- Backend availability detection: HIGH - Try/except ImportError is standard Python pattern

**Research date:** 2026-01-30
**Valid until:** 2026-03-30 (60 days - stable domain, Python packaging evolves slowly)
