---
phase: 11-subprocess-isolation-and-studyrunner
plan: "02"
type: execute
wave: 2
depends_on:
  - "11-01"
files_modified:
  - src/llenergymeasure/study/runner.py
  - src/llenergymeasure/study/gaps.py
  - tests/unit/test_study_runner.py
  - tests/unit/test_study_gaps.py
autonomous: true
requirements:
  - STU-06
  - STU-07

must_haves:
  truths:
    - "First Ctrl+C during an active experiment: sends SIGTERM to child, waits 2-3s grace, then SIGKILL if child still alive; manifest status = 'interrupted'; exits with code 130"
    - "Second Ctrl+C (or grace period expired without child exiting): escalates immediately to SIGKILL"
    - "Ctrl+C during a gap (config_gap or cycle_gap): immediately interrupts the gap and exits — no 'skip gap' interpretation"
    - "config_gap_seconds waits between every consecutive experiment pair; cycle_gap_seconds waits after every complete N-experiment round (where N = number of unique configs)"
    - "Gap display shows inline countdown that overwrites in-place: 'Config gap: 47s remaining (Enter to skip)' or '4m 32s remaining' for > 120s"
    - "Entering Enter during a gap skips the remainder (TTY only); non-TTY environments run the full gap without crashing"
    - "Manifest status set to 'interrupted' (not 'failed') on SIGINT — distinct semantics preserved"
  artifacts:
    - path: "src/llenergymeasure/study/gaps.py"
      provides: "run_gap() — countdown display with Enter-to-skip, SIGINT-safe"
      exports: ["run_gap", "format_gap_duration"]
    - path: "src/llenergymeasure/study/runner.py"
      provides: "SIGINT handler wired into StudyRunner.run(); gap calls inserted between experiments"
    - path: "tests/unit/test_study_gaps.py"
      provides: "Unit tests for run_gap() — TTY and non-TTY paths, SIGINT during gap"
    - path: "tests/unit/test_study_runner.py"
      provides: "SIGINT tests added: first Ctrl+C, second Ctrl+C, interrupt during gap"
  key_links:
    - from: "src/llenergymeasure/study/runner.py"
      to: "src/llenergymeasure/study/gaps.py"
      via: "run_gap(seconds, label, interrupt_event) called between experiments"
      pattern: "run_gap"
    - from: "src/llenergymeasure/study/runner.py"
      to: "src/llenergymeasure/study/manifest.py"
      via: "manifest_writer.manifest status set to 'interrupted' before sys.exit(130)"
      pattern: "interrupted"
    - from: "src/llenergymeasure/study/runner.py"
      to: "signal module"
      via: "threading.Event set by SIGINT handler; checked in run loop and gap"
      pattern: "_interrupt_event"
---

<objective>
Add SIGINT handling and thermal gap countdown to StudyRunner.

Purpose: Studies may run for hours. Users must be able to interrupt cleanly (Ctrl+C) and
see that thermal gaps are progressing (not stalled). Both are correctness requirements:
interrupted manifests must be readable for future --resume support (M4); gap display
prevents the researcher from thinking the tool has hung.

Output:
- `src/llenergymeasure/study/gaps.py` — gap countdown display with Enter-to-skip
- `src/llenergymeasure/study/runner.py` — SIGINT handler wired in, gap calls added
- `tests/unit/test_study_gaps.py` — unit tests for gap display and skip logic
- `tests/unit/test_study_runner.py` — new SIGINT test cases appended
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-subprocess-isolation-and-studyrunner/11-CONTEXT.md
@.planning/phases/11-subprocess-isolation-and-studyrunner/11-01-SUMMARY.md

<interfaces>
<!-- Key contracts needed by the executor. -->

From src/llenergymeasure/study/runner.py (output of Plan 01):
```python
class StudyRunner:
    def __init__(self, study: StudyConfig, manifest_writer: ManifestWriter) -> None: ...
    def run(self) -> list[ExperimentResult | dict]: ...
    def _run_one(self, config, mp_ctx) -> ExperimentResult | dict: ...
    # self._interrupted: bool  -- set True on SIGINT (Plan 01 may have stubbed this)
```

From src/llenergymeasure/study/manifest.py:
```python
class StudyManifest(BaseModel):
    # status field does NOT currently exist — add it as part of this plan
    # It belongs on the top-level StudyManifest, not on individual entries
    # Allowed values: "running" | "completed" | "interrupted" | "failed"
    ...

class ManifestWriter:
    manifest: StudyManifest
    def mark_running(self, ...) -> None: ...
    def mark_completed(self, ...) -> None: ...
    def mark_failed(self, ...) -> None: ...
    # Need new method: mark_interrupted() — sets manifest.status = "interrupted"
```

From 11-CONTEXT.md (locked decisions):
```
SIGINT behaviour:
- First Ctrl+C: SIGTERM to active subprocess, wait 2-3s grace period for clean result
- Second Ctrl+C (or grace period expired): escalate to SIGKILL
- Manifest status = "interrupted" (not "failed")
- Exit code 130
- Ctrl+C during gap = full interrupt, stop study immediately
- Children install signal.signal(signal.SIGINT, signal.SIG_IGN) [done in Plan 01]

Gap countdown UX:
- Inline countdown: "Config gap: 47s remaining (Enter to skip)"
- Label: "Config gap:" vs "Cycle gap:"
- Under 120s: "47s remaining"; over 120s: "4m 32s remaining"
- Enter skips gap (TTY only, degrades gracefully in non-TTY)
- Ctrl+C during gap = full interrupt (no skip interpretation)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status field to StudyManifest and mark_interrupted() to ManifestWriter</name>
  <files>
    src/llenergymeasure/study/manifest.py
    tests/unit/test_study_manifest.py
  </files>
  <action>
Two small additions to the existing manifest module:

**StudyManifest**: Add a top-level `status` field:
```python
status: Literal["running", "completed", "interrupted", "failed"] = Field(
    default="running",
    description="Overall study status. 'interrupted' = user Ctrl+C (not an error).",
)
```
Place this field after `completed_at` in the model.

**ManifestWriter**: Add `mark_interrupted()` method:
```python
def mark_interrupted(self) -> None:
    """Set manifest status to 'interrupted'. Called on SIGINT before sys.exit(130)."""
    self.manifest = self.manifest.model_copy(update={"status": "interrupted"})
    self._write()
```

**Tests in test_study_manifest.py**: Add 2 new tests:
1. `test_manifest_initial_status_is_running` — fresh ManifestWriter has manifest.status == "running"
2. `test_mark_interrupted_sets_status` — after `mark_interrupted()`, manifest.status == "interrupted"
   and the JSON on disk parses as "interrupted"

Do NOT change the existing test for StudyManifest schema (it will need the new field, but
the default value "running" means existing assertions still pass unless they test `extra="forbid"`
— if so, update the dict-based constructor calls to include `status="running"`).
  </action>
  <verify>
    <automated>cd /home/h.baker@hertie-school.lan/workspace/llm-efficiency-measurement-tool && python -m pytest tests/unit/test_study_manifest.py -q 2>&1 | tail -5</automated>
  </verify>
  <done>
  - StudyManifest has `status` field with default "running"
  - ManifestWriter.mark_interrupted() exists and sets status + writes atomically
  - All manifest tests pass (including 2 new ones)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement gaps.py — countdown display with Enter-to-skip</name>
  <files>
    src/llenergymeasure/study/gaps.py
    tests/unit/test_study_gaps.py
  </files>
  <action>
Create `src/llenergymeasure/study/gaps.py` with two public functions:

**format_gap_duration(seconds: float) -> str**:
```python
def format_gap_duration(seconds: float) -> str:
    """Format gap duration for display.
    Under 120s: '47s remaining'
    120s and over: '4m 32s remaining'
    """
    if seconds < 120:
        return f"{int(seconds)}s remaining"
    minutes = int(seconds) // 60
    secs = int(seconds) % 60
    return f"{minutes}m {secs:02d}s remaining"
```

**run_gap(seconds: float, label: str, interrupt_event: threading.Event) -> None**:
```python
def run_gap(seconds: float, label: str, interrupt_event: threading.Event) -> None:
    """Run a thermal gap with inline countdown display and Enter-to-skip.

    Args:
        seconds: Gap duration in seconds.
        label: Display label — "Config gap" or "Cycle gap".
        interrupt_event: threading.Event; if set, aborts the gap immediately
                         (set by SIGINT handler in StudyRunner).
    """
```

Implementation details:
- Display format (each tick overwrites the previous line using `\r`):
  `f"\r{label}: {format_gap_duration(remaining)} (Enter to skip)  "` — trailing spaces clear old chars
- Tick interval: 1 second
- Enter-to-skip: launch a daemon thread that does `sys.stdin.readline()`. If stdin is not a TTY
  (`not sys.stdin.isatty()`), skip launching the thread entirely — non-TTY safe.
  Use a `skip_event = threading.Event()` that the readline thread sets.
- Loop: each second, check `interrupt_event.is_set()` first (hard stop, no print).
  Then check `skip_event.is_set()` (gap skipped — clear line, return).
  Then print the countdown and `time.sleep(1)`.
- On normal completion OR skip: print `\r` + spaces + `\r` to clear the countdown line,
  then print `f"{label}: done\n"`.
- On interrupt (interrupt_event set): clear line, do NOT print "done" — caller handles output.

Implementation choice (Claude's discretion per CONTEXT.md): use `threading.Event` + daemon
readline thread. This is the simplest approach that degrades gracefully in non-TTY environments.

**tests/unit/test_study_gaps.py** — cover:
1. `test_format_gap_duration_under_120s` — "47s remaining"
2. `test_format_gap_duration_over_120s` — "4m 32s remaining"
3. `test_format_gap_duration_exactly_120s` — "2m 00s remaining"
4. `test_run_gap_completes_normally` — pass a 0-second gap (or very short) and confirm no exception
5. `test_run_gap_interrupt_event` — set interrupt_event before calling run_gap; confirm it returns
   immediately (< 0.1s) without printing anything
6. `test_run_gap_non_tty_no_crash` — patch `sys.stdin.isatty` to return False; run 0s gap; no crash
  </action>
  <verify>
    <automated>cd /home/h.baker@hertie-school.lan/workspace/llm-efficiency-measurement-tool && python -m pytest tests/unit/test_study_gaps.py -q 2>&1 | tail -5</automated>
  </verify>
  <done>
  - gaps.py exists with format_gap_duration and run_gap
  - All 6 gap tests pass
  - `from llenergymeasure.study.gaps import run_gap, format_gap_duration` succeeds
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire SIGINT handling and gap calls into StudyRunner</name>
  <files>
    src/llenergymeasure/study/runner.py
    tests/unit/test_study_runner.py
  </files>
  <action>
Modify `StudyRunner.run()` and `StudyRunner._run_one()` in `runner.py` to:

**1. SIGINT handler setup** (in `run()` before the experiment loop):
```python
import signal
import threading

self._interrupt_event = threading.Event()
self._active_process: multiprocessing.Process | None = None
self._interrupt_count = 0

def _sigint_handler(signum, frame):
    self._interrupt_count += 1
    self._interrupt_event.set()
    if self._interrupt_count == 1:
        # First Ctrl+C: SIGTERM to active child, then wait 2-3s grace
        print("\nInterrupt received. Waiting for experiment to finish cleanly (Ctrl+C again to force)...")
        if self._active_process is not None and self._active_process.is_alive():
            self._active_process.terminate()  # SIGTERM — gentle first attempt
    else:
        # Second Ctrl+C: SIGKILL immediately
        print("\nForce-killing experiment subprocess...")
        if self._active_process is not None and self._active_process.is_alive():
            self._active_process.kill()  # SIGKILL

original_sigint = signal.signal(signal.SIGINT, _sigint_handler)
```

**2. Restore signal and exit 130** (after the experiment loop in `run()`):
```python
signal.signal(signal.SIGINT, original_sigint)
if self._interrupt_event.is_set():
    # Print summary before exit
    completed = sum(1 for r in results if isinstance(r, ExperimentResult))
    total = len(ordered)
    print(f"\n{completed}/{total} experiments completed. Results in study directory. Manifest: interrupted.")
    self.manifest.mark_interrupted()
    sys.exit(130)
```

**3. Interrupt check in `_run_one()`**:
- Store the process as `self._active_process = p` before `p.start()`
- After `p.join(timeout=timeout)`, check `self._interrupt_event.is_set()`:
  - If set AND p.is_alive(): do SIGTERM → 2s grace → SIGKILL (the SIGTERM may already have been
    sent by the handler, but send again to be safe)
  - Collect whatever result is available (or mark failed)
  - Return early so run() can proceed to the exit block
- Clear `self._active_process = None` after join + cleanup

**4. Gap calls in `run()`** (inserted between experiments in the ordered loop):
```python
for i, config in enumerate(ordered):
    if self._interrupt_event.is_set():
        break  # SIGINT already received — stop scheduling new experiments

    # Config gap: between every consecutive experiment pair
    if i > 0:
        gap_secs = self.study.execution.config_gap_seconds or 0.0
        if gap_secs > 0:
            run_gap(gap_secs, "Config gap", self._interrupt_event)
            if self._interrupt_event.is_set():
                break

    # Cycle gap: after every complete round (N = number of unique unique configs)
    n_unique = len(self.study.experiments)
    if n_unique > 0 and i > 0 and i % n_unique == 0:
        cycle_gap_secs = self.study.execution.cycle_gap_seconds or 0.0
        if cycle_gap_secs > 0:
            run_gap(cycle_gap_secs, "Cycle gap", self._interrupt_event)
            if self._interrupt_event.is_set():
                break

    result = self._run_one(config, mp_ctx)
    results.append(result)
```

**5. Import `run_gap`** at top of runner.py:
```python
from llenergymeasure.study.gaps import run_gap
```

**6. Add SIGINT tests to tests/unit/test_study_runner.py**:

Test A: `test_sigint_first_ctrl_c_marks_manifest_interrupted`
- Patch the subprocess to simulate: process is alive when SIGINT fires; SIGTERM → process exits
- Trigger _sigint_handler directly (call it programmatically, not via real signal)
- Assert manifest.mark_interrupted() is called and sys.exit(130) is raised

Test B: `test_sigint_during_gap_exits_immediately`
- Patch run_gap to simulate interrupt_event being set during the gap
- Assert that the experiment loop exits and mark_interrupted is called

Test C: `test_sigint_second_ctrl_c_kills_immediately`
- Call _sigint_handler twice; assert p.kill() (SIGKILL) is called on second call

Grace period duration (2-3s range): use 2 seconds (Claude's discretion per CONTEXT.md).
The first-Ctrl+C handler sends SIGTERM; the grace wait happens in `_run_one()` after
`p.join(timeout=total_timeout)` detects `p.is_alive() and interrupt_event.is_set()`:
  ```python
  p.join(timeout=2)  # 2s grace for clean CUDA teardown after SIGTERM
  if p.is_alive():
      p.kill()
      p.join()
  ```
  </action>
  <verify>
    <automated>cd /home/h.baker@hertie-school.lan/workspace/llm-efficiency-measurement-tool && python -m pytest tests/unit/test_study_runner.py tests/unit/test_study_gaps.py tests/unit/test_study_manifest.py -q 2>&1 | tail -8</automated>
  </verify>
  <done>
  - SIGINT handler installed and restored in StudyRunner.run()
  - First Ctrl+C: SIGTERM → 2s grace → SIGKILL if needed
  - Second Ctrl+C: immediate SIGKILL
  - manifest.mark_interrupted() called before sys.exit(130)
  - Gap calls inserted between experiments with interrupt_event threading
  - All 3 new SIGINT tests pass; full test suite passes
  </done>
</task>

</tasks>

<verification>
After all three tasks complete, run the full verification:

```bash
cd /home/h.baker@hertie-school.lan/workspace/llm-efficiency-measurement-tool

# 1. All unit tests pass
python -m pytest tests/unit/ -q 2>&1 | tail -5

# 2. SIGINT handler installed
grep -n "_sigint_handler\|SIGINT\|sys.exit(130)" src/llenergymeasure/study/runner.py

# 3. mark_interrupted exists
grep -n "mark_interrupted\|interrupted" src/llenergymeasure/study/manifest.py

# 4. Gap calls between experiments
grep -n "run_gap\|config_gap\|cycle_gap" src/llenergymeasure/study/runner.py

# 5. Status field on StudyManifest
python -c "from llenergymeasure.study.manifest import StudyManifest; m = StudyManifest.__model_fields__; print('status' in m)"
```
</verification>

<success_criteria>
1. `StudyManifest.status` field exists with default "running"; allowed values include "interrupted"
2. `ManifestWriter.mark_interrupted()` sets status and writes atomically
3. `src/llenergymeasure/study/gaps.py` exists with `run_gap()` and `format_gap_duration()`
4. `run_gap()` degrades gracefully in non-TTY environments (no crash when `sys.stdin.isatty()` is False)
5. SIGINT handler in `StudyRunner.run()`:
   - First Ctrl+C → SIGTERM to child → 2s grace → SIGKILL if alive
   - Second Ctrl+C → immediate SIGKILL
   - Ctrl+C during gap → interrupt_event set → gap exits → run loop exits
6. `manifest.mark_interrupted()` and `sys.exit(130)` called before exiting
7. Config gap fires between every consecutive experiment pair; cycle gap fires after every
   N-experiment round where N = number of unique configs
8. All unit tests pass (no regressions against Plan 01 output)

Note: Manual Ctrl+C GPU hardware test is required but cannot be unit-tested. This is noted
in STATE.md pending todos and will be verified in Phase 12 integration testing.
</success_criteria>

<output>
After completion, create `.planning/phases/11-subprocess-isolation-and-studyrunner/11-02-SUMMARY.md`

Frontmatter:
```
---
plan: 11-02
status: complete
files_modified:
  - src/llenergymeasure/study/manifest.py
  - src/llenergymeasure/study/gaps.py
  - src/llenergymeasure/study/runner.py
  - tests/unit/test_study_manifest.py
  - tests/unit/test_study_gaps.py
  - tests/unit/test_study_runner.py
tests_added: <count>
tests_total: <count>
---
```
</output>
