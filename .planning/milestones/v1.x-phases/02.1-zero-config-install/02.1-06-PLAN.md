---
phase: 02.1-zero-config-install
plan: 06
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - src/llenergymeasure/cli/campaign.py
autonomous: true

must_haves:
  truths:
    - "Campaign mode correctly dispatches multi-backend campaigns to Docker, single-backend locally"
    - "Campaign mode inside Docker container runs locally (no nested Docker)"
    - ".env file is auto-generated before any Docker compose operation in campaign mode"
  artifacts:
    - path: "src/llenergymeasure/cli/campaign.py"
      provides: "Refactored _should_use_docker using docker_detection module, ensure_env_file wired before Docker ops"
  key_links:
    - from: "cli/campaign.py"
      to: "config/docker_detection.py"
      via: "_should_use_docker delegates to should_use_docker_for_campaign"
      pattern: "from.*docker_detection.*import.*should_use_docker_for_campaign"
    - from: "cli/campaign.py"
      to: "config/env_setup.py"
      via: "ensure_env_file called before ContainerManager creation"
      pattern: "from.*env_setup.*import.*ensure_env_file"
---

<objective>
Refactor the broken `_should_use_docker()` in campaign.py to use the new detection modules, and wire `ensure_env_file()` before Docker operations.

Purpose: Campaign mode correctly dispatches to Docker for multi-backend campaigns, runs locally for single-backend when available, and never attempts nested Docker. The .env file is guaranteed to exist before any Docker compose operation.

Output: Refactored campaign.py with proper detection logic and .env auto-generation.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.1-zero-config-install/02.1-CONTEXT.md
@.planning/phases/02.1-zero-config-install/02.1-RESEARCH.md
@src/llenergymeasure/cli/campaign.py
@src/llenergymeasure/config/docker_detection.py (created by Plan 01)
@src/llenergymeasure/config/env_setup.py (created by Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor _should_use_docker() to use detection module</name>
  <files>src/llenergymeasure/cli/campaign.py</files>
  <action>
Replace the current broken `_should_use_docker()` function (lines 856-878) that always returns False.

**New implementation:**
```python
def _should_use_docker(backends: list[str] | None = None) -> bool:
    """Determine if campaign should use Docker orchestration.

    Delegates to the docker_detection module for proper detection.
    """
    from llenergymeasure.config.docker_detection import should_use_docker_for_campaign
    if backends is None:
        backends = ["pytorch"]  # Default fallback
    return should_use_docker_for_campaign(backends)
```

**Update the three call sites to pass backend information:**

1. **`campaign_cmd` function, line ~375** (the `if _should_use_docker():` block):
   - Move `backends_needed = list({exp.backend for exp in execution_order})` from line ~382 to BEFORE the `if _should_use_docker()` call (around line ~374)
   - Change `if _should_use_docker():` to `if _should_use_docker(backends_needed):`
   - The `backends_needed` variable is already computed at line 382 inside the try block; move it up to line ~374, just before the if-statement

2. **`_run_campaign_loop` function, line ~603** (the `if _should_use_docker():` block):
   - Add `backends_needed = list({exp.backend for exp in execution_order})` before line 603
   - Change `if _should_use_docker():` to `if _should_use_docker(backends_needed):`

3. **`_run_single_experiment` function, line ~763**:
   - Change `use_docker = container_mgr is not None or _should_use_docker()` to `use_docker = container_mgr is not None or _should_use_docker([backend])`
   - The `backend` variable is already available from `_detect_backend(config_data)` at line 759
  </action>
  <verify>
```bash
python -c "from llenergymeasure.cli.campaign import _should_use_docker; print(_should_use_docker(['pytorch', 'vllm']))"
# Should return True (multi-backend needs Docker)
python -c "from llenergymeasure.cli.campaign import _should_use_docker; print(_should_use_docker(['pytorch']))"
# Should return True or False depending on pytorch availability and Docker context
ruff check src/llenergymeasure/cli/campaign.py
```
  </verify>
  <done>
`_should_use_docker()` delegates to `should_use_docker_for_campaign()`. All three call sites pass backend information. Multi-backend campaigns dispatch to Docker, single-backend with available backend runs locally, inside-Docker always runs locally.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ensure_env_file() before Docker container creation</name>
  <files>src/llenergymeasure/cli/campaign.py</files>
  <action>
Add `ensure_env_file()` calls before `ContainerManager` is created, ensuring .env exists before any Docker compose operation.

**Insertion point 1: `campaign_cmd` function (line ~375-381)**

After `if _should_use_docker(backends_needed):` returns True and before the `try:` block that imports and creates `ContainerManager`, insert:
```python
    if _should_use_docker(backends_needed):
        # Ensure .env exists before any Docker compose operation
        from llenergymeasure.config.env_setup import ensure_env_file
        ensure_env_file()
        try:
            from llenergymeasure.orchestration.container import (
                ContainerManager as _ContainerManager,
            )
            container_mgr = _ContainerManager(compose_file="docker-compose.yml")
            ...
```

**Insertion point 2: `_run_campaign_loop` function (line ~603-609)**

Same pattern â€” after `if _should_use_docker(backends_needed):` and before the ContainerManager try block:
```python
    if _should_use_docker(backends_needed):
        # Ensure .env exists before any Docker compose operation
        from llenergymeasure.config.env_setup import ensure_env_file
        ensure_env_file()
        try:
            from llenergymeasure.orchestration.container import (
                ContainerManager as _ContainerManager,
            )
            container_mgr = _ContainerManager(compose_file="docker-compose.yml")
            ...
```

Note: The `ensure_env_file` import is lazy (inside the if-block), matching the existing pattern for `ContainerManager` imports. This avoids importing env_setup when Docker is not needed.
  </action>
  <verify>
```bash
# Verify ensure_env_file is called in both locations
python -c "
import ast, inspect
from llenergymeasure.cli import campaign
source = inspect.getsource(campaign)
tree = ast.parse(source)
# Check that 'ensure_env_file' appears in the source
assert 'ensure_env_file' in source, 'ensure_env_file not found in campaign.py'
print('ensure_env_file wired in campaign.py')
"

# Verify .env would be created before Docker operations
# (functional test: call ensure_env_file directly)
python -c "
from llenergymeasure.config.env_setup import ensure_env_file
p = ensure_env_file()
print(f'.env path: {p}, exists: {p.exists()}')
"

ruff check src/llenergymeasure/cli/campaign.py
```
  </verify>
  <done>
`ensure_env_file()` is called in both `campaign_cmd` and `_run_campaign_loop` after Docker dispatch is decided but before `ContainerManager` is created. The .env file (with PUID/PGID) is guaranteed to exist before any `docker compose` operation.
  </done>
</task>

</tasks>

<verification>
```bash
# _should_use_docker delegates properly
python -c "from llenergymeasure.cli.campaign import _should_use_docker; print('multi:', _should_use_docker(['pytorch', 'vllm'])); print('single:', _should_use_docker(['pytorch']))"

# ensure_env_file wired in campaign.py
grep -n 'ensure_env_file' src/llenergymeasure/cli/campaign.py  # Should show 2+ occurrences

# Ruff clean
ruff check src/llenergymeasure/cli/campaign.py
```
</verification>

<success_criteria>
- _should_use_docker() correctly dispatches based on backend availability and Docker context
- All three call sites pass backend information
- ensure_env_file() called before ContainerManager creation in both campaign_cmd and _run_campaign_loop
- ruff check passes on campaign.py
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-zero-config-install/02.1-06-SUMMARY.md`
</output>
