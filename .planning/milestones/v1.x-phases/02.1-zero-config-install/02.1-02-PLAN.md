---
phase: 02.1-zero-config-install
plan: 02
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - src/llenergymeasure/cli/docker.py
  - src/llenergymeasure/cli/backend.py
  - src/llenergymeasure/cli/__init__.py
autonomous: true

must_haves:
  truths:
    - "lem docker setup checks Docker availability, generates .env, optionally builds images"
    - "lem docker status shows Docker readiness (Docker binary, NVIDIA CTK, .env, built images)"
    - "lem docker build <backend> builds a specific backend Docker image"
    - "lem backend list shows which backends are installed and available"
  artifacts:
    - path: "src/llenergymeasure/cli/docker.py"
      provides: "lem docker subcommand group (setup, status, build)"
      exports: ["docker_app"]
    - path: "src/llenergymeasure/cli/backend.py"
      provides: "lem backend subcommand group (list)"
      exports: ["backend_app"]
    - path: "src/llenergymeasure/cli/__init__.py"
      provides: "Registers docker_app and backend_app as Typer subcommands"
  key_links:
    - from: "cli/docker.py"
      to: "config/docker_detection.py"
      via: "imports is_inside_docker"
      pattern: "from.*docker_detection.*import"
    - from: "cli/docker.py"
      to: "config/env_setup.py"
      via: "imports ensure_env_file"
      pattern: "from.*env_setup.*import.*ensure_env_file"
    - from: "cli/backend.py"
      to: "config/backend_detection.py"
      via: "imports get_available_backends, is_backend_available"
      pattern: "from.*backend_detection.*import"
---

<objective>
Create `lem docker` and `lem backend` CLI subcommand groups, wiring the detection modules from Plan 01 into the CLI.

Purpose: Users get Docker lifecycle management (`lem docker setup/status/build`) and backend visibility (`lem backend list`).

Output: Two new CLI modules registered as Typer subcommands.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.1-zero-config-install/02.1-CONTEXT.md
@.planning/phases/02.1-zero-config-install/02.1-RESEARCH.md
@src/llenergymeasure/cli/__init__.py
@src/llenergymeasure/cli/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lem docker subcommand group (setup, status, build)</name>
  <files>src/llenergymeasure/cli/docker.py</files>
  <action>
Create `src/llenergymeasure/cli/docker.py` with a Typer sub-app:

```python
docker_app = typer.Typer(name="docker", help="Docker setup and management for multi-backend campaigns")
```

Three commands:

**`lem docker setup`** (`@docker_app.command("setup")`):
- Parameters: `--backend` / `-b` (list[str], optional, default ["pytorch"])
- Steps:
  1. Check if inside Docker → print warning and exit (code 1)
  2. Check `shutil.which("docker")` → error with install URL if missing
  3. Check `shutil.which("nvidia-container-toolkit")` or run `docker run --rm --gpus all nvidia/cuda:12.0-base nvidia-smi` to verify GPU passthrough → warn if missing
  4. Call `ensure_env_file()` → print confirmation
  5. For each backend: run `subprocess.run(["docker", "compose", "build", backend])` → print confirmation or error
  6. Print summary: "Docker setup complete. Run: lem campaign <config.yaml>"

**`lem docker status`** (`@docker_app.command("status")`):
- No parameters
- Check and display:
  - Docker binary: `shutil.which("docker")` ✓/✗
  - Docker running: `subprocess.run(["docker", "info"], capture_output=True)` ✓/✗
  - NVIDIA CTK: `subprocess.run(["docker", "run", "--rm", "--gpus", "all", "nvidia/cuda:12.0-base", "nvidia-smi"], capture_output=True, timeout=30)` ✓/✗ (catch timeout/error gracefully)
  - .env file: `Path(".env").exists()` ✓/✗
  - Built images: `subprocess.run(["docker", "compose", "images", "--format", "json"], capture_output=True)` → list services with images
- Use Rich console for ✓/✗ display with colours

**`lem docker build`** (`@docker_app.command("build")`):
- Parameters: `backend` (str, positional argument)
- Validate backend against KNOWN_BACKENDS
- Call `ensure_env_file()` (needed for build)
- Run `subprocess.run(["docker", "compose", "build", "base", backend])`
- Print success or error

All commands use lazy imports for detection modules (import inside function body). Use `from llenergymeasure.cli.display import console` for output.
  </action>
  <verify>
`lem docker --help` shows setup, status, build commands. `lem docker status` runs without error (shows Docker readiness).
  </verify>
  <done>
`lem docker setup`, `lem docker status`, `lem docker build` all functional. Docker presence checked, .env generated on setup, images built via docker compose.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lem backend list subcommand</name>
  <files>src/llenergymeasure/cli/backend.py</files>
  <action>
Create `src/llenergymeasure/cli/backend.py` with a Typer sub-app:

```python
backend_app = typer.Typer(name="backend", help="Backend detection and information")
```

One command:

**`lem backend list`** (`@backend_app.command("list")`):
- No parameters
- Import `KNOWN_BACKENDS`, `is_backend_available`, `get_backend_install_hint` from `config.backend_detection`
- For each backend in KNOWN_BACKENDS:
  - Check availability via `is_backend_available(backend)`
  - Display: `✓ pytorch (installed)` or `✗ vllm (not installed — pip install llenergymeasure[vllm])`
- Use Rich console for coloured output (green for installed, red for missing)

Use `from __future__ import annotations`. Lazy-import detection modules inside the command function body.
  </action>
  <verify>
`lem backend list` shows installed backends with ✓/✗ markers and install hints for missing ones.
`ruff check src/llenergymeasure/cli/backend.py`
  </verify>
  <done>
`lem backend list` correctly displays backend availability with colour-coded output and actionable install hints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register docker and backend subcommands in CLI __init__.py</name>
  <files>src/llenergymeasure/cli/__init__.py</files>
  <action>
Update `src/llenergymeasure/cli/__init__.py`:

1. Add imports at top (alongside existing config_app and results_app imports):
   ```python
   from llenergymeasure.cli.docker import docker_app
   from llenergymeasure.cli.backend import backend_app
   ```

2. Register subcommand groups (alongside existing config and results registrations, around line 37):
   ```python
   app.add_typer(docker_app, name="docker")
   app.add_typer(backend_app, name="backend")
   ```

That's it — two import lines and two registration lines. Follow the exact pattern used for `config_app` and `results_app`.
  </action>
  <verify>
`lem --help` shows docker and backend in the command list.
`lem docker --help` shows setup, status, build.
`lem backend --help` shows list.
  </verify>
  <done>
`lem docker` and `lem backend` subcommands visible in CLI help and functional.
  </done>
</task>

</tasks>

<verification>
Full CLI integration check:
```bash
lem --help           # Shows docker, backend subcommands
lem docker --help    # Shows setup, status, build
lem docker status    # Displays Docker readiness
lem backend list     # Shows installed backends
ruff check src/llenergymeasure/cli/docker.py src/llenergymeasure/cli/backend.py
```
</verification>

<success_criteria>
- `lem docker setup`, `lem docker status`, `lem docker build` all functional
- `lem backend list` correctly shows installed/missing backends with actionable hints
- Both subcommand groups registered and visible in `lem --help`
- ruff check passes on all new files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-zero-config-install/02.1-02-SUMMARY.md`
</output>
