---
phase: 02.1-zero-config-install
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/llenergymeasure/config/docker_detection.py
  - src/llenergymeasure/config/backend_detection.py
  - src/llenergymeasure/config/env_setup.py
autonomous: true

must_haves:
  truths:
    - "is_inside_docker() returns True inside Docker containers (/.dockerenv or /proc/1/cgroup)"
    - "is_inside_docker() returns False in conda, venv, and bare-metal Python installs"
    - "is_backend_available(backend) correctly detects installed backends via try/except ImportError"
    - "get_available_backends() lists all importable backends"
    - "should_use_docker_for_campaign(backends) dispatches multi-backend to Docker, single installed backend to local"
    - "ensure_env_file() creates .env with PUID/PGID on first call, skips if .env exists"
  artifacts:
    - path: "src/llenergymeasure/config/docker_detection.py"
      provides: "Docker container detection and campaign dispatch logic"
      exports: ["is_inside_docker", "should_use_docker_for_campaign"]
    - path: "src/llenergymeasure/config/backend_detection.py"
      provides: "Runtime backend availability detection"
      exports: ["is_backend_available", "get_available_backends", "KNOWN_BACKENDS"]
    - path: "src/llenergymeasure/config/env_setup.py"
      provides: "First-run .env file generation for Docker"
      exports: ["ensure_env_file"]
  key_links:
    - from: "docker_detection.py"
      to: "backend_detection.py"
      via: "should_use_docker_for_campaign imports is_backend_available"
      pattern: "from.*backend_detection.*import.*is_backend_available"
---

<objective>
Create the three foundation modules for Phase 2.1: Docker container detection, backend availability detection, and .env auto-generation.

Purpose: These modules replace the broken `_should_use_docker()` in campaign.py and provide the detection logic that all subsequent plans depend on (CLI commands, campaign refactor, packaging).

Output: Three new modules in src/llenergymeasure/config/ with fully typed, tested-ready functions.
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02.1-zero-config-install/02.1-CONTEXT.md
@.planning/phases/02.1-zero-config-install/02.1-RESEARCH.md
@src/llenergymeasure/config/CLAUDE.md
@src/llenergymeasure/cli/campaign.py (lines 856-878 for current broken _should_use_docker)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker_detection.py — container detection + campaign dispatch logic</name>
  <files>src/llenergymeasure/config/docker_detection.py</files>
  <action>
Create `src/llenergymeasure/config/docker_detection.py` with two public functions:

1. `is_inside_docker() -> bool`:
   - Method 1: Check `Path("/.dockerenv").exists()`
   - Method 2: Read `/proc/1/cgroup`, check for "docker" or "containerd" strings
   - Catch `FileNotFoundError` and `PermissionError` for /proc (Windows/macOS compat)
   - Return True if ANY method detects container

2. `should_use_docker_for_campaign(backends: list[str]) -> bool`:
   - If `is_inside_docker()` → return False (no nested containers)
   - If single backend AND `is_backend_available(backend)` → return False (run locally)
   - Otherwise → return True (multi-backend or backend not installed locally)
   - Import `is_backend_available` from `backend_detection` (lazy import inside function to avoid circular deps at module level)

Use `from __future__ import annotations`. Type all parameters and returns. Google-style docstrings with brief descriptions. Import Path from pathlib.

Do NOT add `is_local_python_install()` — the research suggested it but it's unnecessary for the dispatch decision (we only need "inside docker?" and "backend available?").
  </action>
  <verify>
`python -c "from llenergymeasure.config.docker_detection import is_inside_docker, should_use_docker_for_campaign; print(is_inside_docker()); print(should_use_docker_for_campaign(['pytorch']))"` — runs without error, returns False (not in Docker) and a boolean.
  </verify>
  <done>
Both functions importable and callable. `is_inside_docker()` returns False on dev machine. `should_use_docker_for_campaign(['pytorch'])` returns True or False depending on whether pytorch is locally installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backend_detection.py — runtime backend availability</name>
  <files>src/llenergymeasure/config/backend_detection.py</files>
  <action>
Create `src/llenergymeasure/config/backend_detection.py` with:

1. `KNOWN_BACKENDS: list[str] = ["pytorch", "vllm", "tensorrt"]` — single source for backend names

2. `is_backend_available(backend: str) -> bool`:
   - try/except ImportError pattern
   - pytorch: `import torch`
   - vllm: `import vllm`
   - tensorrt: `import tensorrt_llm`
   - Unknown backend: return False
   - Use `# noqa: F401` on imports

3. `get_available_backends() -> list[str]`:
   - Return `[b for b in KNOWN_BACKENDS if is_backend_available(b)]`

4. `get_backend_install_hint(backend: str) -> str`:
   - Returns actionable install command string
   - pytorch: `pip install llenergymeasure[pytorch]`
   - vllm: `pip install llenergymeasure[vllm]`
   - tensorrt: `pip install llenergymeasure[tensorrt]`
   - Unknown: `pip install llenergymeasure[{backend}]`

Use `from __future__ import annotations`. Type all functions. Brief docstrings.
  </action>
  <verify>
`python -c "from llenergymeasure.config.backend_detection import get_available_backends, get_backend_install_hint; print(get_available_backends()); print(get_backend_install_hint('vllm'))"` — runs without error, shows available backends and install hint.
  </verify>
  <done>
All four exports importable and callable. `get_available_backends()` correctly detects installed backends. `get_backend_install_hint()` returns pip install command.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create env_setup.py — first-run .env generation</name>
  <files>src/llenergymeasure/config/env_setup.py</files>
  <action>
Create `src/llenergymeasure/config/env_setup.py` with one public function:

`ensure_env_file(project_root: Path | None = None) -> Path`:
  - If `project_root` is None, infer by walking up from `Path.cwd()` looking for `pyproject.toml` or `.git` directory. Fallback to `Path.cwd()`.
  - Check `env_file = project_root / ".env"`
  - If `.env` exists → return path immediately (never overwrite)
  - If missing → generate with `os.getuid()` and `os.getgid()` (Unix-only, Docker is Linux-only)
  - Content format:
    ```
    # Auto-generated by llenergymeasure
    # Docker user mapping for correct file ownership
    PUID={puid}
    PGID={pgid}
    ```
  - Log once via `loguru.logger.info(f"Generated .env with PUID={puid} PGID={pgid} for Docker")`
  - Return path to .env file

Use `from __future__ import annotations`. Import `os`, `Path` from pathlib, `logger` from loguru. Type all params and returns.
  </action>
  <verify>
`python -c "from llenergymeasure.config.env_setup import ensure_env_file; p = ensure_env_file(); print(p, p.exists())"` — runs without error, prints path and True (if .env exists or was created).
  </verify>
  <done>
`ensure_env_file()` creates .env with PUID/PGID when missing, returns path. Calling twice does not overwrite.
  </done>
</task>

</tasks>

<verification>
All three modules importable:
```bash
python -c "
from llenergymeasure.config.docker_detection import is_inside_docker, should_use_docker_for_campaign
from llenergymeasure.config.backend_detection import is_backend_available, get_available_backends, KNOWN_BACKENDS, get_backend_install_hint
from llenergymeasure.config.env_setup import ensure_env_file
print('All imports OK')
print('Docker:', is_inside_docker())
print('Backends:', get_available_backends())
"
```

Type checking: `ruff check src/llenergymeasure/config/docker_detection.py src/llenergymeasure/config/backend_detection.py src/llenergymeasure/config/env_setup.py`
</verification>

<success_criteria>
- Three new modules exist in src/llenergymeasure/config/
- All public functions importable and callable
- is_inside_docker() returns False on dev machine
- get_available_backends() correctly detects installed backends
- ensure_env_file() creates .env when missing, skips when present
- ruff check passes on all three files
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-zero-config-install/02.1-01-SUMMARY.md`
</output>
