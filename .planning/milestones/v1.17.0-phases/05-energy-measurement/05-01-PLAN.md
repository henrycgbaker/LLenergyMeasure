---
phase: 05-energy-measurement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/llenergymeasure/core/energy_backends/nvml.py
  - src/llenergymeasure/core/energy_backends/zeus.py
  - src/llenergymeasure/core/energy_backends/__init__.py
  - pyproject.toml
  - tests/unit/test_energy_backends_v2.py
autonomous: true
requirements: [CM-11, CM-12, CM-13, CM-14]

must_haves:
  truths:
    - "NVMLBackend implements EnergyBackend protocol and integrates power samples to joules via trapezoidal rule"
    - "ZeusBackend wraps ZeusMonitor and returns EnergyMeasurement with per-GPU joule breakdown"
    - "select_energy_backend('auto') returns Zeus when available, NVML otherwise, CodeCarbon as fallback, None when no GPU"
    - "select_energy_backend('zeus') raises ConfigError with install guidance when zeus not installed"
    - "select_energy_backend(None) (null in YAML) returns None without warnings"
    - "pyproject.toml zeus extra uses 'zeus>=0.13.1' not 'zeus-ml'"
  artifacts:
    - path: "src/llenergymeasure/core/energy_backends/nvml.py"
      provides: "NVMLBackend: poll + trapezoidal integrate to joules"
      contains: "class NVMLBackend"
    - path: "src/llenergymeasure/core/energy_backends/zeus.py"
      provides: "ZeusBackend: ZeusMonitor wrapper"
      contains: "class ZeusBackend"
    - path: "src/llenergymeasure/core/energy_backends/__init__.py"
      provides: "select_energy_backend() auto-selection function"
      contains: "def select_energy_backend"
    - path: "tests/unit/test_energy_backends_v2.py"
      provides: "Unit tests for NVMLBackend, ZeusBackend, auto-selection"
  key_links:
    - from: "src/llenergymeasure/core/energy_backends/__init__.py"
      to: "src/llenergymeasure/core/energy_backends/nvml.py"
      via: "select_energy_backend imports NVMLBackend"
      pattern: "from.*nvml.*import.*NVMLBackend"
    - from: "src/llenergymeasure/core/energy_backends/__init__.py"
      to: "src/llenergymeasure/core/energy_backends/zeus.py"
      via: "select_energy_backend probes zeus via importlib.util.find_spec"
      pattern: "find_spec.*zeus"
---

<objective>
Create the three energy measurement backends (NVML, Zeus, CodeCarbon) with auto-selection and register them in the energy backends registry. Fix the zeus package name in pyproject.toml.

Purpose: Energy backends are the foundation for all energy measurement in Phase 5. Without them, the measurement integration (Plan 03) has nothing to call.
Output: Three EnergyBackend implementations, a selector function, pyproject.toml fix, and unit tests.

Note: EnergyConfig and measurement_warnings are added in Plan 02 (which owns config/models.py and domain/experiment.py to avoid file ownership conflicts).
</objective>

<execution_context>
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/workflows/execute-plan.md
@/home/h.baker@hertie-school.lan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-energy-measurement/05-CONTEXT.md
@.planning/phases/05-energy-measurement/05-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/llenergymeasure/protocols.py:
```python
@runtime_checkable
class EnergyBackend(Protocol):
    @property
    def name(self) -> str: ...
    def start_tracking(self) -> Any: ...
    def stop_tracking(self, tracker: Any) -> Any: ...
    def is_available(self) -> bool: ...
```

From src/llenergymeasure/core/power_thermal.py:
```python
@dataclass
class PowerThermalSample:
    timestamp: float
    power_w: float | None = None
    memory_used_mb: float | None = None
    memory_total_mb: float | None = None
    temperature_c: float | None = None
    sm_utilisation: float | None = None
    thermal_throttle: bool = False
    throttle_reasons: int = 0

class PowerThermalSampler:
    def __init__(self, device_index: int = 0, sample_interval_ms: int = 100) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def get_samples(self) -> list[PowerThermalSample]: ...
    def get_power_samples(self) -> list[float]: ...
```

From src/llenergymeasure/core/energy_backends/__init__.py:
```python
_BACKENDS: dict[str, type[EnergyBackend]] = {}
def register_backend(name: str, backend_cls: type[EnergyBackend]) -> None: ...
def get_backend(name: str, **kwargs: object) -> EnergyBackend: ...
def list_backends() -> list[str]: ...
```

From src/llenergymeasure/config/models.py:
```python
class ExperimentConfig(BaseModel):
    model_config = {"extra": "forbid"}
    # ... fields ...
    warmup: WarmupConfig = Field(...)
    baseline: BaselineConfig = Field(...)
    # energy: EnergyConfig — DOES NOT EXIST YET, must add
```

From src/llenergymeasure/domain/experiment.py:
```python
class ExperimentResult(BaseModel):
    # ... existing fields ...
    # measurement_warnings — DOES NOT EXIST YET, must add
    model_config = {"frozen": True}
```

From src/llenergymeasure/exceptions.py:
```python
class ConfigError(LLEMError): ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NVMLBackend, ZeusBackend, auto-selection, and update registry</name>
  <files>
    src/llenergymeasure/core/energy_backends/nvml.py
    src/llenergymeasure/core/energy_backends/zeus.py
    src/llenergymeasure/core/energy_backends/__init__.py
    pyproject.toml
  </files>
  <action>
  **Create `src/llenergymeasure/core/energy_backends/nvml.py`:**

  Implement `NVMLBackend` that satisfies the `EnergyBackend` protocol. This wraps `PowerThermalSampler` into an energy backend that polls at 100ms and integrates to joules.

  - `name` property returns `"nvml"`
  - `is_available()`: try `pynvml.nvmlInit()` / `nvmlShutdown()`, return True/False. Use deferred import.
  - `start_tracking()`: create `PowerThermalSampler(device_index=self._device_index, sample_interval_ms=100)`, call `.start()`, return the sampler.
  - `stop_tracking(tracker)`: call `tracker.stop()`, get samples, do trapezoidal integration to compute total joules. Return an `EnergyMeasurement` dataclass.
  - Define `EnergyMeasurement` dataclass in this file: `total_j: float`, `duration_sec: float`, `samples: list`, `per_gpu_j: dict[int, float] | None = None`.
  - Trapezoidal integration: iterate consecutive sample pairs, `dt = s[i+1].timestamp - s[i].timestamp`, `avg_power = (s[i+1].power_w + s[i].power_w) / 2`, `total_j += avg_power * dt`. Skip samples where power_w is None.
  - Constructor takes `device_index: int = 0`.
  - All imports deferred (no module-level pynvml or torch imports).

  **Create `src/llenergymeasure/core/energy_backends/zeus.py`:**

  Implement `ZeusBackend` that wraps `ZeusMonitor`.

  - `name` property returns `"zeus"`
  - `is_available()`: try `from zeus.monitor import ZeusMonitor`, return True on success, False on ImportError.
  - `WINDOW_NAME = "llem_measurement"` class constant
  - `start_tracking()`: create `ZeusMonitor(gpu_indices=self._gpu_indices)`, call `monitor.begin_window(WINDOW_NAME)`, return monitor.
  - `stop_tracking(tracker)`: call `tracker.end_window(WINDOW_NAME)`, extract `measurement.energy` (dict[int, float] = gpu_idx -> joules) and `measurement.time`. Sum energy values. Return `EnergyMeasurement`.
  - Constructor takes `gpu_indices: list[int] | None = None`.
  - Import `EnergyMeasurement` from `.nvml` (shared dataclass).
  - All imports deferred.

  **Update `src/llenergymeasure/core/energy_backends/__init__.py`:**

  Replace the existing registry-based approach with a direct `select_energy_backend()` function (the old registry can stay for backward compat, but the new function is the primary API).

  Add `select_energy_backend(explicit: str | None) -> EnergyBackend | None`:
  - If `explicit is None`: return `None` (intentional disable, maps from YAML `null`). No warnings.
  - If `explicit` is a specific backend name (`"nvml"`, `"zeus"`, `"codecarbon"`): instantiate it, check `is_available()`, raise `ConfigError` with install guidance if unavailable.
  - If `explicit == "auto"` (or default): probe in order: Zeus (via `importlib.util.find_spec("zeus")`), then NVML (always available on GPU machines), then CodeCarbon (via `find_spec("codecarbon")`). Return first available, or `None` if nothing works.
  - Import `ConfigError` from `llenergymeasure.exceptions`.

  Register NVMLBackend in `_register_default_backends()` alongside CodeCarbonBackend.
  Add NVMLBackend, ZeusBackend, select_energy_backend, and EnergyMeasurement to `__all__`.

  **Update `pyproject.toml`:**

  Change the zeus extra from `zeus-ml>=0.10` to `zeus>=0.13.1`. This fixes the abandoned package reference (zeus-ml stopped at v0.11.0, zeus 0.15.0 is current).
  </action>
  <verify>
    <automated>cd /home/h.baker@hertie-school.lan/workspace/llm-efficiency-measurement-tool && python -c "from llenergymeasure.core.energy_backends import select_energy_backend, NVMLBackend, EnergyMeasurement; print('imports OK')" && python -c "from llenergymeasure.core.energy_backends.nvml import NVMLBackend, EnergyMeasurement; b = NVMLBackend(); assert b.name == 'nvml'; print('NVMLBackend OK')" && python -c "from llenergymeasure.core.energy_backends.zeus import ZeusBackend; b = ZeusBackend(); assert b.name == 'zeus'; print('ZeusBackend OK')" && python -c "from llenergymeasure.core.energy_backends import select_energy_backend; r = select_energy_backend(None); assert r is None; print('null disable OK')" && grep -q 'zeus>=0.13.1' pyproject.toml && echo 'pyproject.toml OK'</automated>
  </verify>
  <done>NVMLBackend integrates power samples to joules via trapezoidal rule. ZeusBackend wraps ZeusMonitor. select_energy_backend() implements Zeus > NVML > CodeCarbon priority with explicit override and null disable. pyproject.toml uses correct zeus package name.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for energy backends and auto-selection</name>
  <files>
    tests/unit/test_energy_backends_v2.py
  </files>
  <action>
  **Create `tests/unit/test_energy_backends_v2.py`:**

  Write focused unit tests (no GPU required, all mocked):

  1. `test_nvml_backend_name()` — `NVMLBackend().name == "nvml"`
  2. `test_zeus_backend_name()` — `ZeusBackend().name == "zeus"`
  3. `test_nvml_is_available_no_gpu()` — mock pynvml import failure, assert `is_available() == False`
  4. `test_zeus_is_available_no_package()` — mock zeus import failure, assert `is_available() == False`
  5. `test_select_backend_null_returns_none()` — `select_energy_backend(None) is None`
  6. `test_select_backend_explicit_unavailable_raises()` — mock backend unavailable, assert ConfigError with install guidance
  7. `test_select_backend_auto_priority()` — mock find_spec to control which backends are "installed", verify priority order
  8. `test_energy_measurement_dataclass()` — construct EnergyMeasurement, verify fields
  9. `test_nvml_trapezoidal_integration()` — create synthetic PowerThermalSamples, call stop_tracking with mocked sampler, verify joules are correct. Create 3 samples at t=0.0, t=0.1, t=0.2 with power_w=100.0 each, expected joules = 100.0 * 0.2 = 20.0 (within tolerance).

  Use `unittest.mock.patch` and `pytest` fixtures. Import from the correct v2.0 modules.
  </action>
  <verify>
    <automated>cd /home/h.baker@hertie-school.lan/workspace/llm-efficiency-measurement-tool && python -m pytest tests/unit/test_energy_backends_v2.py -x -v 2>&1 | tail -20</automated>
  </verify>
  <done>All 9 unit tests pass — NVMLBackend, ZeusBackend, auto-selection, trapezoidal integration, null disable all verified.</done>
</task>

</tasks>

<verification>
1. `python -c "from llenergymeasure.core.energy_backends import select_energy_backend, NVMLBackend, ZeusBackend, EnergyMeasurement"` — all imports resolve
2. `python -c "from llenergymeasure.core.energy_backends import select_energy_backend; assert select_energy_backend(None) is None"` — null disable works
3. `grep 'zeus>=0.13.1' pyproject.toml` — package name fixed
4. `python -m pytest tests/unit/test_energy_backends_v2.py -x -v` — all tests pass
</verification>

<success_criteria>
- NVMLBackend, ZeusBackend, and CodeCarbonBackend all satisfy EnergyBackend protocol
- select_energy_backend() returns correct backend for all input modes (auto, explicit, null)
- pyproject.toml uses zeus>=0.13.1
- 9+ unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-energy-measurement/05-01-SUMMARY.md`
</output>
